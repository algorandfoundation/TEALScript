#pragma version 10
intcblock 1 8 0 400 16 32768 2
bytecblock 0x 0x63757272656e74496e646578

// This TEAL was generated by TEALScript v0.107.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// startUpload(string,uint64,uint64,pay)void
*abi_route_startUpload:
	// mbrPayment: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 0 (mbrPayment) for startUpload must be a pay transaction
	assert

	// endBoxSize: uint64
	txna ApplicationArgs 3
	btoi

	// numBoxes: uint64
	txna ApplicationArgs 2
	btoi

	// dataIdentifier: string
	txna ApplicationArgs 1
	extract 2 0

	// execute startUpload(string,uint64,uint64,pay)void
	callsub startUpload
	intc 0 // 1
	return

// startUpload(dataIdentifier: string, numBoxes: uint64, endBoxSize: uint64, mbrPayment: PayTxn): void
//
//
// Allocate boxes to begin data upload process
//
// @param dataIdentifier The unique identifier for the data
// @param numBoxes The number of boxes that the data will take up
// @param endBoxSize The size of the last box
// @param mbrPayment Payment from the uploader to cover the box MBR
startUpload:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// examples/big_box/big_box.algo.ts:41
	// startBox = this.currentIndex.value
	bytec 1 //  "currentIndex"
	app_global_get
	frame_bury 0 // startBox: uint64

	// examples/big_box/big_box.algo.ts:42
	// endBox = startBox + numBoxes - 1
	frame_dig 0 // startBox: uint64
	frame_dig -2 // numBoxes: uint64
	+
	intc 0 // 1
	-
	frame_bury 1 // endBox: uint64

	// examples/big_box/big_box.algo.ts:44
	// metadata: Metadata = {
	//       start: startBox,
	//       end: endBox,
	//       status: IN_PROGRESS,
	//       endSize: endBoxSize,
	//     }
	frame_dig 0 // startBox: uint64
	itob
	frame_dig 1 // endBox: uint64
	itob
	concat
	pushbytes 0x00
	concat
	frame_dig -3 // endBoxSize: uint64
	itob
	concat
	frame_bury 2 // metadata: Metadata

	// examples/big_box/big_box.algo.ts:51
	// assert(!this.metadata(dataIdentifier).exists)
	frame_dig -1 // dataIdentifier: string
	box_len
	swap
	pop
	!
	assert

	// examples/big_box/big_box.algo.ts:53
	// this.metadata(dataIdentifier).value = metadata
	frame_dig -1 // dataIdentifier: string
	frame_dig 2 // metadata: Metadata
	box_put

	// examples/big_box/big_box.algo.ts:55
	// this.currentIndex.value = endBox + 1
	bytec 1 //  "currentIndex"
	frame_dig 1 // endBox: uint64
	intc 0 // 1
	+
	app_global_put

	// examples/big_box/big_box.algo.ts:57
	// totalCost =
	//       numBoxes * COST_PER_BOX + // cost of boxes
	//       (numBoxes - 1) * MAX_BOX_SIZE * COST_PER_BYTE + // cost of data
	//       numBoxes * 64 * COST_PER_BYTE + // cost of keys
	//       endBoxSize * COST_PER_BYTE
	frame_dig -2 // numBoxes: uint64
	pushint 2500
	*
	frame_dig -2 // numBoxes: uint64
	intc 0 // 1
	-
	intc 5 // 32768
	*
	intc 3 // 400
	*
	+
	frame_dig -2 // numBoxes: uint64
	pushint 64
	*
	intc 3 // 400
	*
	+
	frame_dig -3 // endBoxSize: uint64
	intc 3 // 400
	*
	+
	frame_bury 3 // totalCost: uint64

	// examples/big_box/big_box.algo.ts:63
	// verifyPayTxn(mbrPayment, { receiver: this.app.address, amount: totalCost })
	// verify receiver
	frame_dig -4 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -4 // mbrPayment: PayTxn
	gtxns Amount
	frame_dig 3 // totalCost: uint64
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"amount","expected":"totalCost"}
	assert
	retsub

// upload(string,uint64,uint64,byte[])void
*abi_route_upload:
	// data: byte[]
	txna ApplicationArgs 4
	extract 2 0

	// offset: uint64
	txna ApplicationArgs 3
	btoi

	// boxIndex: uint64
	txna ApplicationArgs 2
	btoi

	// dataIdentifier: string
	txna ApplicationArgs 1
	extract 2 0

	// execute upload(string,uint64,uint64,byte[])void
	callsub upload
	intc 0 // 1
	return

// upload(dataIdentifier: string, boxIndex: uint64, offset: uint64, data: bytes): void
//
//
// Upload data to a specific offset in a box
//
// @param dataIdentifier The unique identifier for the data
// @param boxIndex The index of the box to upload the given chunk of data to
// @param offset The offset within the box to start writing the data
// @param data The data to write
upload:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// examples/big_box/big_box.algo.ts:76
	// metadata = this.metadata(dataIdentifier).value
	frame_dig -1 // dataIdentifier: string
	frame_bury 0 // storage key//metadata

	// examples/big_box/big_box.algo.ts:77
	// assert(metadata.status === IN_PROGRESS)
	frame_dig -1 // dataIdentifier: string
	intc 4 //  headOffset
	intc 0 // 1
	box_extract
	btoi
	intc 2 // 0
	==
	assert

	// examples/big_box/big_box.algo.ts:78
	// assert(metadata.start <= boxIndex && boxIndex <= metadata.end)
	frame_dig -1 // dataIdentifier: string
	intc 2 // 0
	intc 1 // 8
	box_extract
	btoi
	frame_dig -2 // boxIndex: uint64
	<=
	dup
	bz *skip_and0
	frame_dig -2 // boxIndex: uint64
	frame_dig -1 // dataIdentifier: string
	intc 1 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	<=
	&&

*skip_and0:
	assert

	// *if0_condition
	// examples/big_box/big_box.algo.ts:80
	// offset === 0
	frame_dig -3 // offset: uint64
	intc 2 // 0
	==
	bz *if0_end

	// *if0_consequent
	// examples/big_box/big_box.algo.ts:81
	// this.dataBoxes(boxIndex).create(boxIndex === metadata.end ? metadata.endSize : MAX_BOX_SIZE)
	frame_dig -2 // boxIndex: uint64
	itob
	frame_dig -2 // boxIndex: uint64
	frame_dig -1 // dataIdentifier: string
	intc 1 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	==
	bz *ternary0_false
	frame_dig -1 // dataIdentifier: string
	pushint 17 // headOffset
	intc 1 // 8
	box_extract
	btoi
	b *ternary0_end

*ternary0_false:
	intc 5 // 32768

*ternary0_end:
	box_create
	pop

*if0_end:
	// examples/big_box/big_box.algo.ts:84
	// this.dataBoxes(boxIndex).replace(offset, data)
	frame_dig -2 // boxIndex: uint64
	itob
	frame_dig -3 // offset: uint64
	frame_dig -4 // data: bytes
	box_replace
	retsub

// setStatus(string,uint8)void
*abi_route_setStatus:
	// status: uint8
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 1
	==

	// argument 0 (status) for setStatus must be a uint8
	assert
	btoi

	// dataIdentifier: string
	txna ApplicationArgs 1
	extract 2 0

	// execute setStatus(string,uint8)void
	callsub setStatus
	intc 0 // 1
	return

// setStatus(dataIdentifier: string, status: uint<8>): void
//
//
// Set the status of the data
//
// @param dataIdentifier The unique identifier for the data
// @param status The new status for the data
setStatus:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// examples/big_box/big_box.algo.ts:95
	// currentStatus = this.metadata(dataIdentifier).value.status
	frame_dig -1 // dataIdentifier: string
	intc 4 //  headOffset
	intc 0 // 1
	box_extract
	btoi
	frame_bury 0 // currentStatus: uint8

	// examples/big_box/big_box.algo.ts:97
	// assert(status === READY || status === IMMUTABLE || status === IN_PROGRESS)
	frame_dig -2 // status: uint<8>
	intc 0 // 1
	==
	dup
	bnz *skip_or0
	frame_dig -2 // status: uint<8>
	intc 6 // 2
	==
	||

*skip_or0:
	dup
	bnz *skip_or1
	frame_dig -2 // status: uint<8>
	intc 2 // 0
	==
	||

*skip_or1:
	assert

	// examples/big_box/big_box.algo.ts:98
	// assert(currentStatus !== IMMUTABLE)
	frame_dig 0 // currentStatus: uint8
	intc 6 // 2
	!=
	assert

	// examples/big_box/big_box.algo.ts:100
	// this.metadata(dataIdentifier).value.status = status
	intc 4 //  headOffset
	frame_dig -2 // status: uint<8>
	itob
	extract 7 1
	frame_dig -1 // dataIdentifier: string
	cover 2
	box_replace
	retsub

*abi_route_createApplication:
	intc 0 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xa05b5669 // method "startUpload(string,uint64,uint64,pay)void"
	pushbytes 0x1b7dfa35 // method "upload(string,uint64,uint64,byte[])void"
	pushbytes 0xbf3856f8 // method "setStatus(string,uint8)void"
	txna ApplicationArgs 0
	match *abi_route_startUpload *abi_route_upload *abi_route_setStatus

	// this contract does not implement the given ABI method for call NoOp
	err