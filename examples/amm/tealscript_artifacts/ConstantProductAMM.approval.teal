#pragma version 10
intcblock 0 10000000000 1 1000
bytecblock 0x 0x61 0x62 0x67 0x70 0x72

// This TEAL was generated by TEALScript v0.104.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	int 1
	return

// createApplication(): void
createApplication:
	proto 0 0

	// examples/amm/amm.algo.ts:20
	// this.governor.value = this.txn.sender
	byte 0x67 // "g"
	txn Sender
	app_global_put
	retsub

// doCreatePoolToken(aAsset: AssetID, bAsset: AssetID): AssetID
doCreatePoolToken:
	proto 2 1

	// examples/amm/amm.algo.ts:26
	// return sendAssetCreation({
	//       configAssetName: 'DPT-' + aAsset.unitName + '-' + bAsset.unitName,
	//       configAssetUnitName: 'dpt',
	//       configAssetTotal: TOTAL_SUPPLY,
	//       configAssetDecimals: 3,
	//       configAssetManager: this.app.address,
	//       configAssetReserve: this.app.address,
	//     });
	itxn_begin
	pushint 3 // acfg
	itxn_field TypeEnum

	// examples/amm/amm.algo.ts:27
	// configAssetName: 'DPT-' + aAsset.unitName + '-' + bAsset.unitName
	pushbytes 0x4450542d // "DPT-"
	frame_dig -1 // aAsset: AssetID
	asset_params_get AssetUnitName
	pop
	concat
	pushbytes 0x2d // "-"
	concat
	frame_dig -2 // bAsset: AssetID
	asset_params_get AssetUnitName
	pop
	concat
	itxn_field ConfigAssetName

	// examples/amm/amm.algo.ts:28
	// configAssetUnitName: 'dpt'
	pushbytes 0x647074 // "dpt"
	itxn_field ConfigAssetUnitName

	// examples/amm/amm.algo.ts:29
	// configAssetTotal: TOTAL_SUPPLY
	int 10000000000
	itxn_field ConfigAssetTotal

	// examples/amm/amm.algo.ts:30
	// configAssetDecimals: 3
	pushint 3
	itxn_field ConfigAssetDecimals

	// examples/amm/amm.algo.ts:31
	// configAssetManager: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetManager

	// examples/amm/amm.algo.ts:32
	// configAssetReserve: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetReserve

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID
	retsub

// doAxfer(receiver: Address, asset: AssetID, amount: uint64): void
doAxfer:
	proto 3 0

	// examples/amm/amm.algo.ts:37
	// sendAssetTransfer({
	//       assetReceiver: receiver,
	//       xferAsset: asset,
	//       assetAmount: amount,
	//     })
	itxn_begin
	pushint 4 // axfer
	itxn_field TypeEnum

	// examples/amm/amm.algo.ts:38
	// assetReceiver: receiver
	frame_dig -1 // receiver: Address
	itxn_field AssetReceiver

	// examples/amm/amm.algo.ts:39
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// examples/amm/amm.algo.ts:40
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// doOptIn(asset: AssetID): void
doOptIn:
	proto 1 0

	// examples/amm/amm.algo.ts:45
	// this.doAxfer(this.app.address, asset, 0)
	int 0
	frame_dig -1 // asset: AssetID
	global CurrentApplicationAddress
	callsub doAxfer
	retsub

// tokensToMintIntial(aAmount: uint64, bAmount: uint64): uint64
tokensToMintIntial:
	proto 2 1

	// examples/amm/amm.algo.ts:49
	// return sqrt(aAmount * bAmount);
	frame_dig -1 // aAmount: uint64
	frame_dig -2 // bAmount: uint64
	*
	sqrt
	retsub

// tokensToMint(issued: uint64, aSupply: uint64, bSupply: uint64, aAmount: uint64, bAmount: uint64): uint64
tokensToMint:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// examples/amm/amm.algo.ts:53
	// aRatio = wideRatio([aAmount, SCALE], [aSupply])
	frame_dig -4 // aAmount: uint64
	int 1000
	mulw
	int 0
	frame_dig -2 // aSupply: uint64
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 0 // aRatio: uint64

	// examples/amm/amm.algo.ts:54
	// bRatio = wideRatio([bAmount, SCALE], [bSupply])
	frame_dig -5 // bAmount: uint64
	int 1000
	mulw
	int 0
	frame_dig -3 // bSupply: uint64
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 1 // bRatio: uint64

	// examples/amm/amm.algo.ts:56
	// ratio = aRatio < bRatio ? aRatio : bRatio
	frame_dig 0 // aRatio: uint64
	frame_dig 1 // bRatio: uint64
	<
	bz *ternary0_false
	frame_dig 0 // aRatio: uint64
	b *ternary0_end

*ternary0_false:
	frame_dig 1 // bRatio: uint64

*ternary0_end:
	frame_bury 2 // ratio: uint64

	// examples/amm/amm.algo.ts:58
	// return wideRatio([ratio, issued], [SCALE]);
	frame_dig 2 // ratio: uint64
	frame_dig -1 // issued: uint64
	mulw
	int 0
	int 1000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// computeRatio(): uint64
computeRatio:
	proto 0 1

	// examples/amm/amm.algo.ts:62
	// return wideRatio(
	//       [this.app.address.assetBalance(this.assetA.value), SCALE],
	//       [this.app.address.assetBalance(this.assetB.value)]
	//     );
	global CurrentApplicationAddress
	byte 0x61 // "a"
	app_global_get
	asset_holding_get AssetBalance
	pop
	int 1000
	mulw
	int 0
	global CurrentApplicationAddress
	byte 0x62 // "b"
	app_global_get
	asset_holding_get AssetBalance
	pop
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	retsub

// tokensToBurn(issued: uint64, supply: uint64, amount: uint64): uint64
tokensToBurn:
	proto 3 1

	// examples/amm/amm.algo.ts:69
	// return wideRatio([supply, amount], [issued]);
	frame_dig -2 // supply: uint64
	frame_dig -3 // amount: uint64
	mulw
	int 0
	frame_dig -1 // issued: uint64
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	retsub

// tokensToSwap(inAmount: uint64, inSupply: uint64, outSupply: uint64): uint64
tokensToSwap:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// examples/amm/amm.algo.ts:73
	// factor = SCALE - FEE
	pushint 995
	frame_bury 0 // factor: uint64

	// examples/amm/amm.algo.ts:74
	// return wideRatio([inAmount, factor, outSupply], [inSupply * SCALE + inAmount * factor]);
	frame_dig -1 // inAmount: uint64
	frame_dig 0 // factor: uint64
	mulw
	frame_dig -3 // outSupply: uint64
	uncover 2
	dig 1
	*
	cover 2
	mulw
	cover 2
	+
	swap
	int 0
	frame_dig -2 // inSupply: uint64
	int 1000
	*
	frame_dig -1 // inAmount: uint64
	frame_dig 0 // factor: uint64
	*
	+
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert

	// set the subroutine return value
	frame_bury 0
	retsub

// set_governor(address)void
*abi_route_set_governor:
	// governor: address
	txna ApplicationArgs 1
	dup
	len
	pushint 32
	==

	// argument 0 (governor) for set_governor must be a address
	assert

	// execute set_governor(address)void
	callsub set_governor
	int 1
	return

// set_governor(governor: Address): void
set_governor:
	proto 1 0

	// examples/amm/amm.algo.ts:78
	// verifyAppCallTxn(this.txn, { sender: this.governor.value })
	// verify sender
	txn Sender
	byte 0x67 // "g"
	app_global_get
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"this.governor.value"}
	assert

	// examples/amm/amm.algo.ts:79
	// this.governor.value = governor
	byte 0x67 // "g"
	frame_dig -1 // governor: Address
	app_global_put
	retsub

// bootstrap(pay,uint64,uint64)uint64
*abi_route_bootstrap:
	// The ABI return prefix
	pushbytes 0x151f7c75

	// bAsset: uint64
	txna ApplicationArgs 2
	btoi

	// aAsset: uint64
	txna ApplicationArgs 1
	btoi

	// seed: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int 1 // pay
	==

	// argument 2 (seed) for bootstrap must be a pay transaction
	assert

	// execute bootstrap(pay,uint64,uint64)uint64
	callsub bootstrap
	itob
	concat
	log
	int 1
	return

// bootstrap(seed: PayTxn, aAsset: AssetID, bAsset: AssetID): AssetID
bootstrap:
	proto 3 1

	// examples/amm/amm.algo.ts:83
	// verifyAppCallTxn(this.txn, { sender: this.governor.value })
	// verify sender
	txn Sender
	byte 0x67 // "g"
	app_global_get
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"this.governor.value"}
	assert

	// examples/amm/amm.algo.ts:85
	// assert(globals.groupSize === 2)
	global GroupSize
	pushint 2
	==
	assert

	// examples/amm/amm.algo.ts:87
	// verifyPayTxn(seed, { receiver: this.app.address, amount: { greaterThanEqualTo: 300_000 } })
	// verify receiver
	frame_dig -1 // seed: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"seed","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // seed: PayTxn
	gtxns Amount
	pushint 300_000
	>=

	// transaction verification failed: {"txn":"seed","field":"amount","condition":"greaterThanEqualTo","expected":">=300_000"}
	assert

	// examples/amm/amm.algo.ts:88
	// assert(aAsset < bAsset)
	frame_dig -2 // aAsset: AssetID
	frame_dig -3 // bAsset: AssetID
	<
	assert

	// examples/amm/amm.algo.ts:90
	// this.assetA.value = aAsset
	byte 0x61 // "a"
	frame_dig -2 // aAsset: AssetID
	app_global_put

	// examples/amm/amm.algo.ts:91
	// this.assetB.value = bAsset
	byte 0x62 // "b"
	frame_dig -3 // bAsset: AssetID
	app_global_put

	// examples/amm/amm.algo.ts:92
	// this.poolToken.value = this.doCreatePoolToken(aAsset, bAsset)
	byte 0x70 // "p"
	frame_dig -3 // bAsset: AssetID
	frame_dig -2 // aAsset: AssetID
	callsub doCreatePoolToken
	app_global_put

	// examples/amm/amm.algo.ts:94
	// this.doOptIn(aAsset)
	frame_dig -2 // aAsset: AssetID
	callsub doOptIn

	// examples/amm/amm.algo.ts:95
	// this.doOptIn(bAsset)
	frame_dig -3 // bAsset: AssetID
	callsub doOptIn

	// examples/amm/amm.algo.ts:97
	// return this.poolToken.value;
	byte 0x70 // "p"
	app_global_get
	retsub

// mint(axfer,axfer,uint64,uint64,uint64)void
*abi_route_mint:
	// bAsset: uint64
	txna ApplicationArgs 3
	btoi

	// aAsset: uint64
	txna ApplicationArgs 2
	btoi

	// poolAsset: uint64
	txna ApplicationArgs 1
	btoi

	// bXfer: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	pushint 4 // axfer
	==

	// argument 3 (bXfer) for mint must be a axfer transaction
	assert

	// aXfer: axfer
	txn GroupIndex
	pushint 2
	-
	dup
	gtxns TypeEnum
	pushint 4 // axfer
	==

	// argument 4 (aXfer) for mint must be a axfer transaction
	assert

	// execute mint(axfer,axfer,uint64,uint64,uint64)void
	callsub mint
	int 1
	return

// mint(aXfer: AssetTransferTxn, bXfer: AssetTransferTxn, poolAsset: AssetID, aAsset: AssetID, bAsset: AssetID): void
mint:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// well formed mint
	// examples/amm/amm.algo.ts:102
	// assert(aAsset === this.assetA.value)
	frame_dig -4 // aAsset: AssetID
	byte 0x61 // "a"
	app_global_get
	==
	assert

	// examples/amm/amm.algo.ts:103
	// assert(bAsset === this.assetB.value)
	frame_dig -5 // bAsset: AssetID
	byte 0x62 // "b"
	app_global_get
	==
	assert

	// examples/amm/amm.algo.ts:104
	// assert(poolAsset === this.poolToken.value)
	frame_dig -3 // poolAsset: AssetID
	byte 0x70 // "p"
	app_global_get
	==
	assert

	// valid asset A axfer
	// examples/amm/amm.algo.ts:107
	// verifyAssetTransferTxn(aXfer, {
	//       sender: this.txn.sender,
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       xferAsset: aAsset,
	//     })
	// verify sender
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"aXfer","field":"sender","expected":"this.txn.sender"}
	assert

	// verify assetAmount
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	int 0
	>

	// transaction verification failed: {"txn":"aXfer","field":"assetAmount","condition":"greaterThan","expected":">0"}
	assert

	// verify assetReceiver
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"aXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -4 // aAsset: AssetID
	==

	// transaction verification failed: {"txn":"aXfer","field":"xferAsset","expected":"aAsset"}
	assert

	// valid asset B axfer
	// examples/amm/amm.algo.ts:115
	// verifyAssetTransferTxn(bXfer, {
	//       sender: this.txn.sender,
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       xferAsset: bAsset,
	//     })
	// verify sender
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"bXfer","field":"sender","expected":"this.txn.sender"}
	assert

	// verify assetAmount
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	int 0
	>

	// transaction verification failed: {"txn":"bXfer","field":"assetAmount","condition":"greaterThan","expected":">0"}
	assert

	// verify assetReceiver
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"bXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -5 // bAsset: AssetID
	==

	// transaction verification failed: {"txn":"bXfer","field":"xferAsset","expected":"bAsset"}
	assert

	// *if0_condition
	// examples/amm/amm.algo.ts:123
	// this.app.address.assetBalance(aAsset) === aXfer.assetAmount &&
	//       this.app.address.assetBalance(bAsset) === bXfer.assetAmount
	global CurrentApplicationAddress
	frame_dig -4 // aAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	==
	dup
	bz *skip_and0
	global CurrentApplicationAddress
	frame_dig -5 // bAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	==
	&&

*skip_and0:
	bz *if0_else

	// *if0_consequent
	// examples/amm/amm.algo.ts:126
	// this.tokensToMintIntial(aXfer.assetAmount, bXfer.assetAmount)
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	callsub tokensToMintIntial
	b *if0_end

*if0_else:
	// examples/amm/amm.algo.ts:128
	// toMint = this.tokensToMint(
	//         TOTAL_SUPPLY - this.app.address.assetBalance(poolAsset),
	//         this.app.address.assetBalance(aAsset) - aXfer.assetAmount,
	//         this.app.address.assetBalance(bAsset) - bXfer.assetAmount,
	//         aXfer.assetAmount,
	//         bXfer.assetAmount
	//       )
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	global CurrentApplicationAddress
	frame_dig -5 // bAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -2 // bXfer: AssetTransferTxn
	gtxns AssetAmount
	-
	global CurrentApplicationAddress
	frame_dig -4 // aAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -1 // aXfer: AssetTransferTxn
	gtxns AssetAmount
	-
	int 10000000000
	global CurrentApplicationAddress
	frame_dig -3 // poolAsset: AssetID
	asset_holding_get AssetBalance
	pop
	-
	callsub tokensToMint
	frame_bury 0 // toMint: uint64

	// examples/amm/amm.algo.ts:136
	// assert(toMint > 0)
	frame_dig 0 // toMint: uint64
	int 0
	>
	assert

	// examples/amm/amm.algo.ts:138
	// this.doAxfer(this.txn.sender, poolAsset, toMint)
	frame_dig 0 // toMint: uint64
	frame_dig -3 // poolAsset: AssetID
	txn Sender
	callsub doAxfer

*if0_end:
	retsub

// burn(axfer,uint64,uint64,uint64)void
*abi_route_burn:
	// bAsset: uint64
	txna ApplicationArgs 3
	btoi

	// aAsset: uint64
	txna ApplicationArgs 2
	btoi

	// poolAsset: uint64
	txna ApplicationArgs 1
	btoi

	// poolXfer: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	pushint 4 // axfer
	==

	// argument 3 (poolXfer) for burn must be a axfer transaction
	assert

	// execute burn(axfer,uint64,uint64,uint64)void
	callsub burn
	int 1
	return

// burn(poolXfer: AssetTransferTxn, poolAsset: AssetID, aAsset: AssetID, bAsset: AssetID): void
burn:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// well formed burn
	// examples/amm/amm.algo.ts:144
	// assert(poolAsset === this.poolToken.value)
	frame_dig -2 // poolAsset: AssetID
	byte 0x70 // "p"
	app_global_get
	==
	assert

	// examples/amm/amm.algo.ts:145
	// assert(aAsset === this.assetA.value)
	frame_dig -3 // aAsset: AssetID
	byte 0x61 // "a"
	app_global_get
	==
	assert

	// examples/amm/amm.algo.ts:146
	// assert(bAsset === this.assetB.value)
	frame_dig -4 // bAsset: AssetID
	byte 0x62 // "b"
	app_global_get
	==
	assert

	// valid pool axfer
	// examples/amm/amm.algo.ts:149
	// verifyAssetTransferTxn(poolXfer, {
	//       sender: this.txn.sender,
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       xferAsset: poolAsset,
	//     })
	// verify sender
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"poolXfer","field":"sender","expected":"this.txn.sender"}
	assert

	// verify assetAmount
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetAmount
	int 0
	>

	// transaction verification failed: {"txn":"poolXfer","field":"assetAmount","condition":"greaterThan","expected":">0"}
	assert

	// verify assetReceiver
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"poolXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // poolAsset: AssetID
	==

	// transaction verification failed: {"txn":"poolXfer","field":"xferAsset","expected":"poolAsset"}
	assert

	// examples/amm/amm.algo.ts:156
	// issued = TOTAL_SUPPLY - (this.app.address.assetBalance(poolAsset) - poolXfer.assetAmount)
	int 10000000000
	global CurrentApplicationAddress
	frame_dig -2 // poolAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetAmount
	-
	-
	frame_bury 0 // issued: uint64

	// examples/amm/amm.algo.ts:158
	// aAmt = this.tokensToBurn(issued, this.app.address.assetBalance(aAsset), poolXfer.assetAmount)
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetAmount
	global CurrentApplicationAddress
	frame_dig -3 // aAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig 0 // issued: uint64
	callsub tokensToBurn
	frame_bury 1 // aAmt: uint64

	// examples/amm/amm.algo.ts:160
	// bAmt = this.tokensToBurn(issued, this.app.address.assetBalance(bAsset), poolXfer.assetAmount)
	frame_dig -1 // poolXfer: AssetTransferTxn
	gtxns AssetAmount
	global CurrentApplicationAddress
	frame_dig -4 // bAsset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig 0 // issued: uint64
	callsub tokensToBurn
	frame_bury 2 // bAmt: uint64

	// examples/amm/amm.algo.ts:162
	// this.doAxfer(this.txn.sender, aAsset, aAmt)
	frame_dig 1 // aAmt: uint64
	frame_dig -3 // aAsset: AssetID
	txn Sender
	callsub doAxfer

	// examples/amm/amm.algo.ts:163
	// this.doAxfer(this.txn.sender, bAsset, bAmt)
	frame_dig 2 // bAmt: uint64
	frame_dig -4 // bAsset: AssetID
	txn Sender
	callsub doAxfer

	// examples/amm/amm.algo.ts:165
	// this.ratio.value = this.computeRatio()
	byte 0x72 // "r"
	callsub computeRatio
	app_global_put
	retsub

// swap(axfer,uint64,uint64)void
*abi_route_swap:
	// bAsset: uint64
	txna ApplicationArgs 2
	btoi

	// aAsset: uint64
	txna ApplicationArgs 1
	btoi

	// swapXfer: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	pushint 4 // axfer
	==

	// argument 2 (swapXfer) for swap must be a axfer transaction
	assert

	// execute swap(axfer,uint64,uint64)void
	callsub swap
	int 1
	return

// swap(swapXfer: AssetTransferTxn, aAsset: AssetID, bAsset: AssetID): void
swap:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// well formed swap
	// examples/amm/amm.algo.ts:170
	// assert(aAsset === this.assetA.value)
	frame_dig -2 // aAsset: AssetID
	byte 0x61 // "a"
	app_global_get
	==
	assert

	// examples/amm/amm.algo.ts:171
	// assert(bAsset === this.assetB.value)
	frame_dig -3 // bAsset: AssetID
	byte 0x62 // "b"
	app_global_get
	==
	assert

	// examples/amm/amm.algo.ts:173
	// verifyAssetTransferTxn(swapXfer, {
	//       assetAmount: { greaterThan: 0 },
	//       assetReceiver: this.app.address,
	//       sender: this.txn.sender,
	//       xferAsset: { includedIn: [aAsset, bAsset] },
	//     })
	// verify assetAmount
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetAmount
	int 0
	>

	// transaction verification failed: {"txn":"swapXfer","field":"assetAmount","condition":"greaterThan","expected":">0"}
	assert

	// verify assetReceiver
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"swapXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify sender
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"swapXfer","field":"sender","expected":"this.txn.sender"}
	assert

	// verify xferAsset
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // aAsset: AssetID
	==
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -3 // bAsset: AssetID
	==
	||

	// transaction verification failed: {"txn":{"txnText":"swapXfer"},"field":"xferAsset","condition":"includedIn","expected":"[aAsset, bAsset]"}
	assert

	// examples/amm/amm.algo.ts:180
	// outId = swapXfer.xferAsset === aAsset ? aAsset : bAsset
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -2 // aAsset: AssetID
	==
	bz *ternary1_false
	frame_dig -2 // aAsset: AssetID
	b *ternary1_end

*ternary1_false:
	frame_dig -3 // bAsset: AssetID

*ternary1_end:
	frame_bury 0 // outId: uint64

	// examples/amm/amm.algo.ts:182
	// inId = swapXfer.xferAsset
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns XferAsset
	frame_bury 1 // inId: uint64

	// examples/amm/amm.algo.ts:184
	// toSwap = this.tokensToSwap(
	//       swapXfer.assetAmount,
	//       this.app.address.assetBalance(inId) - swapXfer.assetAmount,
	//       this.app.address.assetBalance(outId)
	//     )
	global CurrentApplicationAddress
	frame_dig 0 // outId: uint64
	asset_holding_get AssetBalance
	pop
	global CurrentApplicationAddress
	frame_dig 1 // inId: uint64
	asset_holding_get AssetBalance
	pop
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetAmount
	-
	frame_dig -1 // swapXfer: AssetTransferTxn
	gtxns AssetAmount
	callsub tokensToSwap
	frame_bury 2 // toSwap: uint64

	// examples/amm/amm.algo.ts:190
	// assert(toSwap > 0)
	frame_dig 2 // toSwap: uint64
	int 0
	>
	assert

	// examples/amm/amm.algo.ts:192
	// this.doAxfer(this.txn.sender, outId, toSwap)
	frame_dig 2 // toSwap: uint64
	frame_dig 0 // outId: uint64
	txn Sender
	callsub doAxfer

	// examples/amm/amm.algo.ts:194
	// this.ratio.value = this.computeRatio()
	byte 0x72 // "r"
	callsub computeRatio
	app_global_put
	retsub

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xddc4cb4a // method "set_governor(address)void"
	pushbytes 0x25e6c376 // method "bootstrap(pay,uint64,uint64)uint64"
	pushbytes 0x10045c79 // method "mint(axfer,axfer,uint64,uint64,uint64)void"
	pushbytes 0x028e37c1 // method "burn(axfer,uint64,uint64,uint64)void"
	pushbytes 0x632aaed8 // method "swap(axfer,uint64,uint64)void"
	txna ApplicationArgs 0
	match *abi_route_set_governor *abi_route_bootstrap *abi_route_mint *abi_route_burn *abi_route_swap

	// this contract does not implement the given ABI method for call NoOp
	err