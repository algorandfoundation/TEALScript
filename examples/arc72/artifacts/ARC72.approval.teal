#pragma version 10
intcblock 32 1 256 0 288
bytecblock 0x 0x151f7c75 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 0x696e646578

// This TEAL was generated by TEALScript v0.107.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// arc72_ownerOf(uint256)address
*abi_route_arc72_ownerOf:
	// The ABI return prefix
	bytec 1 // 0x151f7c75

	// tokenId: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 0 (tokenId) for arc72_ownerOf must be a uint256
	assert

	// execute arc72_ownerOf(uint256)address
	callsub arc72_ownerOf
	concat
	log
	intc 1 // 1
	return

// arc72_ownerOf(tokenId: uint256): Address
//
//
// Returns the address of the current owner of the NFT with the given tokenId
//
// @param tokenId The ID of the NFT
// @returns The current owner of the NFT
arc72_ownerOf:
	proto 1 1

	// examples/arc72/arc72.algo.ts:25
	// return this.tokenBox(tokenId).value.owner;
	frame_dig -1 // tokenId: uint256
	intc 3 // 0
	intc 0 // 32
	box_extract
	retsub

// arc72_tokenURI(uint256)byte[256]
*abi_route_arc72_tokenURI:
	// The ABI return prefix
	bytec 1 // 0x151f7c75

	// tokenId: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 0 (tokenId) for arc72_tokenURI must be a uint256
	assert

	// execute arc72_tokenURI(uint256)byte[256]
	callsub arc72_tokenURI
	concat
	log
	intc 1 // 1
	return

// arc72_tokenURI(tokenId: uint256): Bytes256
//
//
// Returns a URI pointing to the NFT metadata
//
// @param tokenId The ID of the NFT
// @returns URI to token metadata
arc72_tokenURI:
	proto 1 1

	// examples/arc72/arc72.algo.ts:37
	// return this.tokenBox(tokenId).value.uri;
	frame_dig -1 // tokenId: uint256
	intc 0 //  headOffset
	intc 2 // 256
	box_extract
	retsub

// transferTo(to: Address, tokenId: uint256): void
transferTo:
	proto 2 0

	// examples/arc72/arc72.algo.ts:41
	// this.tokenBox(tokenId).value.owner = to
	frame_dig -2 // tokenId: uint256
	intc 3 // 0
	frame_dig -1 // to: Address
	box_replace
	retsub

// arc72_transferFrom(address,address,uint256)void
*abi_route_arc72_transferFrom:
	// tokenId: uint256
	txna ApplicationArgs 3
	dup
	len
	intc 0 // 32
	==

	// argument 0 (tokenId) for arc72_transferFrom must be a uint256
	assert

	// to: address
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 1 (to) for arc72_transferFrom must be a address
	assert

	// _from: address
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 2 (_from) for arc72_transferFrom must be a address
	assert

	// execute arc72_transferFrom(address,address,uint256)void
	callsub arc72_transferFrom
	intc 1 // 1
	return

// arc72_transferFrom(_from: Address, to: Address, tokenId: uint256): void
//
// Transfers ownership of an NFT
arc72_transferFrom:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// examples/arc72/arc72.algo.ts:48
	// token = this.tokenBox(tokenId).value
	frame_dig -3 // tokenId: uint256
	frame_bury 0 // storage key//token

	// examples/arc72/arc72.algo.ts:50
	// key: Control = { owner: this.txn.sender, controller: _from }
	txn Sender
	frame_dig -1 // _from: Address
	concat
	frame_bury 1 // key: Control

	// *if0_condition
	// examples/arc72/arc72.algo.ts:52
	// this.txn.sender === _from || this.txn.sender === token.controller || this.controlBox(key).exists
	txn Sender
	frame_dig -1 // _from: Address
	==
	dup
	bnz *skip_or0
	txn Sender
	frame_dig -3 // tokenId: uint256
	intc 4 //  headOffset
	intc 0 // 32
	box_extract
	==
	||

*skip_or0:
	dup
	bnz *skip_or1
	frame_dig 1 // key: Control
	box_len
	swap
	pop
	||

*skip_or1:
	bz *if0_else

	// *if0_consequent
	// examples/arc72/arc72.algo.ts:53
	// this.transferTo(to, tokenId)
	frame_dig -3 // tokenId: uint256
	frame_dig -2 // to: Address
	callsub transferTo
	b *if0_end

*if0_else:
	// Transfer not authorized
	err

*if0_end:
	retsub

// arc72_approve(address,uint256)void
*abi_route_arc72_approve:
	// tokenId: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 32
	==

	// argument 0 (tokenId) for arc72_approve must be a uint256
	assert

	// approved: address
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 1 (approved) for arc72_approve must be a address
	assert

	// execute arc72_approve(address,uint256)void
	callsub arc72_approve
	intc 1 // 1
	return

// arc72_approve(approved: Address, tokenId: uint256): void
//
//
// Approve a controller for a single NFT
//
// @param approved Approved controller address
// @param tokenId The ID of the NFT
arc72_approve:
	proto 2 0

	// examples/arc72/arc72.algo.ts:65
	// this.tokenBox(tokenId).value.controller = approved
	frame_dig -2 // tokenId: uint256
	intc 4 //  headOffset
	frame_dig -1 // approved: Address
	box_replace
	retsub

// arc72_setApprovalForAll(address,bool)void
*abi_route_arc72_setApprovalForAll:
	// approved: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 0 (approved) for arc72_setApprovalForAll must be a bool
	assert
	intc 3 // 0
	getbit

	// operator: address
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 1 (operator) for arc72_setApprovalForAll must be a address
	assert

	// execute arc72_setApprovalForAll(address,bool)void
	callsub arc72_setApprovalForAll
	intc 1 // 1
	return

// arc72_setApprovalForAll(operator: Address, approved: boolean): void
//
//
// Approve an operator for all NFTs for a user
//
// @param operator Approved operator address
// @param approved true to give approval, false to revoke
// @returns
arc72_setApprovalForAll:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// examples/arc72/arc72.algo.ts:77
	// key: Control = { owner: this.txn.sender, controller: operator }
	txn Sender
	frame_dig -1 // operator: Address
	concat
	frame_bury 0 // key: Control

	// *if1_condition
	// examples/arc72/arc72.algo.ts:79
	// approved
	frame_dig -2 // approved: boolean
	bz *if1_elseif1_condition

	// *if1_consequent
	// examples/arc72/arc72.algo.ts:79
	// this.controlBox(key).value = ''
	frame_dig 0 // key: Control
	dup
	box_del
	pop
	bytec 0 //  ""
	box_put
	b *if1_end

*if1_elseif1_condition:
	// examples/arc72/arc72.algo.ts:80
	// this.controlBox(key).exists
	frame_dig 0 // key: Control
	box_len
	swap
	pop
	bz *if1_end

	// *if1_elseif1_consequent
	// examples/arc72/arc72.algo.ts:80
	// this.controlBox(key).delete()
	frame_dig 0 // key: Control
	box_del

*if1_end:
	retsub

// mint(address)void
*abi_route_mint:
	// to: address
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 0 (to) for mint must be a address
	assert

	// execute mint(address)void
	callsub mint
	intc 1 // 1
	return

// mint(to: Address): void
mint:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// examples/arc72/arc72.algo.ts:84
	// index = this.index.value
	bytec 3 //  "index"
	app_global_get
	frame_bury 0 // index: uint256

	// examples/arc72/arc72.algo.ts:86
	// token: Token = {
	//       owner: to,
	//       uri: 'https://github.com/algorandfoundation/ARCs' as Bytes256,
	//       controller: Address.zeroAddress,
	//     }
	frame_dig -1 // to: Address
	pushbytes 0x68747470733a2f2f6769746875622e636f6d2f616c676f72616e64666f756e646174696f6e2f4152437300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 // "https://github.com/algorandfoundation/ARCs"
	concat
	global ZeroAddress
	concat
	frame_bury 1 // token: Token

	// examples/arc72/arc72.algo.ts:92
	// this.tokenBox(index).value = token
	frame_dig 0 // index: uint256
	frame_dig 1 // token: Token
	box_put

	// examples/arc72/arc72.algo.ts:93
	// this.transferTo(to, index)
	frame_dig 0 // index: uint256
	frame_dig -1 // to: Address
	callsub transferTo

	// examples/arc72/arc72.algo.ts:94
	// this.index.value = index + 1
	bytec 3 //  "index"
	frame_dig 0 // index: uint256
	pushbytes 0x0000000000000000000000000000000000000000000000000000000000000001
	b+
	dup
	bitlen
	intc 2 // 256
	<=

	// index + 1 overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	app_global_put
	retsub

// arc72_totalSupply()uint256
*abi_route_arc72_totalSupply:
	// The ABI return prefix
	bytec 1 // 0x151f7c75

	// execute arc72_totalSupply()uint256
	callsub arc72_totalSupply
	dup
	bitlen
	intc 2 // 256
	<=

	// arc72_totalSupply return value overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 1 // 1
	return

// arc72_totalSupply(): uint256
//
// Returns the number of NFTs currently defined by this contract
arc72_totalSupply:
	proto 0 1

	// examples/arc72/arc72.algo.ts:102
	// return this.index.value;
	bytec 3 //  "index"
	app_global_get
	retsub

// arc72_tokenByIndex(uint256)uint256
*abi_route_arc72_tokenByIndex:
	// The ABI return prefix
	bytec 1 // 0x151f7c75

	// index: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 32
	==

	// argument 0 (index) for arc72_tokenByIndex must be a uint256
	assert

	// execute arc72_tokenByIndex(uint256)uint256
	callsub arc72_tokenByIndex
	dup
	bitlen
	intc 2 // 256
	<=

	// arc72_tokenByIndex return value overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 0 // 32
	-
	swap
	substring3
	concat
	log
	intc 1 // 1
	return

// arc72_tokenByIndex(index: uint256): uint256
//
// Returns the token ID of the token with the given index among all NFTs defined by the contract
arc72_tokenByIndex:
	proto 1 1

	// examples/arc72/arc72.algo.ts:110
	// return index;
	frame_dig -1 // index: uint256
	retsub

*abi_route_createApplication:
	intc 1 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x79096a14 // method "arc72_ownerOf(uint256)address"
	pushbytes 0xc3c1fc00 // method "arc72_tokenURI(uint256)byte[256]"
	pushbytes 0xf2f194a0 // method "arc72_transferFrom(address,address,uint256)void"
	pushbytes 0xb4edba4e // method "arc72_approve(address,uint256)void"
	pushbytes 0x7134395f // method "arc72_setApprovalForAll(address,bool)void"
	pushbytes 0xac4cfadf // method "mint(address)void"
	pushbytes 0x64d72a7a // method "arc72_totalSupply()uint256"
	pushbytes 0x6d9bfd27 // method "arc72_tokenByIndex(uint256)uint256"
	txna ApplicationArgs 0
	match *abi_route_arc72_ownerOf *abi_route_arc72_tokenURI *abi_route_arc72_transferFrom *abi_route_arc72_approve *abi_route_arc72_setApprovalForAll *abi_route_mint *abi_route_arc72_totalSupply *abi_route_arc72_tokenByIndex

	// this contract does not implement the given ABI method for call NoOp
	err