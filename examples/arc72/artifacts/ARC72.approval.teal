#pragma version 9

// This TEAL was generated by TEALScript v0.43.0
// https://github.com/algorand-devrel/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its repsective branch will be "NOT_IMPLMENTED" which just contains "err"
txn ApplicationID
int 0
>
int 6
*
txn OnCompletion
+
switch create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED call_NoOp

NOT_IMPLEMENTED:
	err

// arc72_ownerOf(uint256)address
//
// 
// Returns the address of the current owner of the NFT with the given tokenId
// 
// @param tokenId The ID of the NFT
// @returns The current owner of the NFT
abi_route_arc72_ownerOf:
	// tokenId: uint256
	txna ApplicationArgs 1

	// execute arc72_ownerOf(uint256)address
	callsub arc72_ownerOf
	int 1
	return

arc72_ownerOf:
	proto 1 0

	// examples/arc72/arc72.algo.ts:25
	// return this.tokenBox(tokenId).value.owner;
	frame_dig -1 // tokenId: uint256
	box_get
	assert
	frame_dig -1 // tokenId: uint256
	box_get
	assert
	store 0 // full array
	int 0 // initial offset
	int 0 // headOffset
	+
	load 0 // full array
	swap
	int 32
	extract3
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// arc72_tokenURI(uint256)byte[256]
//
// 
// Returns a URI pointing to the NFT metadata
// 
// @param tokenId The ID of the NFT
// @returns URI to token metadata
abi_route_arc72_tokenURI:
	// tokenId: uint256
	txna ApplicationArgs 1

	// execute arc72_tokenURI(uint256)byte[256]
	callsub arc72_tokenURI
	int 1
	return

arc72_tokenURI:
	proto 1 0

	// examples/arc72/arc72.algo.ts:37
	// return this.tokenBox(tokenId).value.uri;
	frame_dig -1 // tokenId: uint256
	box_get
	assert
	frame_dig -1 // tokenId: uint256
	box_get
	assert
	store 0 // full array
	int 0 // initial offset
	int 32 // headOffset
	+
	load 0 // full array
	swap
	int 256
	extract3
	byte 0x151f7c75
	swap
	concat
	log
	retsub

transferTo:
	proto 2 0

	// examples/arc72/arc72.algo.ts:41
	// this.tokenBox(tokenId).value.owner = to
	frame_dig -2 // tokenId: uint256
	box_get
	assert
	store 0 // full array
	int 0 // initial offset
	int 0 // headOffset
	+
	load 0 // full array
	swap
	frame_dig -1 // to: address
	replace3
	frame_dig -2 // tokenId: uint256
	swap
	box_put
	retsub

// arc72_transferFrom(uint256,address,address)void
//
// Transfers ownership of an NFT
abi_route_arc72_transferFrom:
	byte 0x; dup // push empty bytes to fill the stack frame for this subroutine's local variables

	// tokenId: uint256
	txna ApplicationArgs 3

	// to: address
	txna ApplicationArgs 2

	// _from: address
	txna ApplicationArgs 1

	// execute arc72_transferFrom(uint256,address,address)void
	callsub arc72_transferFrom
	int 1
	return

arc72_transferFrom:
	proto 5 0

	// examples/arc72/arc72.algo.ts:48
	// token = this.tokenBox(tokenId).value
	frame_dig -3 // tokenId: uint256
	frame_bury -4 // storage key//token

	// examples/arc72/arc72.algo.ts:50
	// key: Control = { owner: this.txn.sender, controller: _from }
	txn Sender
	frame_dig -1 // _from: address
	concat
	frame_bury -5 // key: Control

	// if0_condition
	// examples/arc72/arc72.algo.ts:53
	// this.txn.sender === _from
	//       || this.txn.sender === token.controller
	//       || this.controlBox(key).exists
	txn Sender
	frame_dig -1 // _from: address
	==
	dup
	bnz skip_or0
	txn Sender
	frame_dig -4 // storage key//token
	box_get
	assert
	store 0 // full array
	int 0 // initial offset
	int 288 // headOffset
	+
	load 0 // full array
	swap
	int 32
	extract3
	==
	||

skip_or0:
	dup
	bnz skip_or1
	frame_dig -5 // key: Control
	box_len
	swap
	pop
	||

skip_or1:
	bz if0_else

	// if0_consequent
	// examples/arc72/arc72.algo.ts:57
	// this.transferTo(to, tokenId)
	frame_dig -3 // tokenId: uint256
	frame_dig -2 // to: address
	callsub transferTo
	b if0_end

if0_else:
	err // 'Transfer not authorized'

if0_end:
	retsub

// arc72_approve(uint256,address)void
//
// 
// Approve a controller for a single NFT
// 
// @param approved Approved controller address
// @param tokenId The ID of the NFT
abi_route_arc72_approve:
	// tokenId: uint256
	txna ApplicationArgs 2

	// approved: address
	txna ApplicationArgs 1

	// execute arc72_approve(uint256,address)void
	callsub arc72_approve
	int 1
	return

arc72_approve:
	proto 2 0

	// examples/arc72/arc72.algo.ts:69
	// this.tokenBox(tokenId).value.controller = approved
	frame_dig -2 // tokenId: uint256
	box_get
	assert
	store 0 // full array
	int 0 // initial offset
	int 288 // headOffset
	+
	load 0 // full array
	swap
	frame_dig -1 // approved: address
	replace3
	frame_dig -2 // tokenId: uint256
	swap
	box_put
	retsub

// arc72_setApprovalForAll(bool,address)void
//
// 
// Approve an operator for all NFTs for a user
// 
// @param operator Approved operator address
// @param approved true to give approval, false to revoke
// @returns
abi_route_arc72_setApprovalForAll:
	byte 0x // push empty bytes to fill the stack frame for this subroutine's local variables

	// approved: bool
	txna ApplicationArgs 2
	int 0
	getbit

	// operator: address
	txna ApplicationArgs 1

	// execute arc72_setApprovalForAll(bool,address)void
	callsub arc72_setApprovalForAll
	int 1
	return

arc72_setApprovalForAll:
	proto 3 0

	// examples/arc72/arc72.algo.ts:81
	// key: Control = { owner: this.txn.sender, controller: operator }
	txn Sender
	frame_dig -1 // operator: address
	concat
	frame_bury -3 // key: Control

	// if1_condition
	// examples/arc72/arc72.algo.ts:83
	// approved
	frame_dig -2 // approved: bool
	bz if1_elseif1_condition

	// if1_consequent
	// examples/arc72/arc72.algo.ts:83
	// this.controlBox(key).value = ''
	frame_dig -3 // key: Control
	dup
	box_del
	pop
	byte ""
	box_put
	b if1_end

if1_elseif1_condition:
	// examples/arc72/arc72.algo.ts:84
	// this.controlBox(key).exists
	frame_dig -3 // key: Control
	box_len
	swap
	pop
	bz if1_end

	// if1_elseif1_consequent
	// examples/arc72/arc72.algo.ts:84
	// this.controlBox(key).delete()
	frame_dig -3 // key: Control
	box_del

if1_end:
	retsub

// mint(address)void
abi_route_mint:
	byte 0x; dup // push empty bytes to fill the stack frame for this subroutine's local variables

	// to: address
	txna ApplicationArgs 1

	// execute mint(address)void
	callsub mint
	int 1
	return

mint:
	proto 3 0

	// examples/arc72/arc72.algo.ts:88
	// index = this.index.value
	byte "index"
	app_global_get
	frame_bury -2 // index: uint256

	// examples/arc72/arc72.algo.ts:90
	// token: Token = {
	//       owner: to,
	//       uri: 'https://github.com/algorandfoundation/ARCs' as Bytes256,
	//       controller: Address.zeroAddress,
	//     }
	frame_dig -1 // to: address
	byte "https://github.com/algorandfoundation/ARCs\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	concat
	global ZeroAddress
	concat
	frame_bury -3 // token: Token

	// examples/arc72/arc72.algo.ts:96
	// this.tokenBox(index).value = token
	frame_dig -2 // index: uint256
	frame_dig -3 // token: Token
	box_put

	// examples/arc72/arc72.algo.ts:97
	// this.transferTo(to, index)
	frame_dig -2 // index: uint256
	frame_dig -1 // to: address
	callsub transferTo

	// examples/arc72/arc72.algo.ts:98
	// this.index.value = index + (1 as uint<256>)
	byte "index"
	frame_dig -2 // index: uint256
	byte 0x0000000000000000000000000000000000000000000000000000000000000001
	b+
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dupn 2
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b<=
	assert
	len
	int 32
	-
	int 32
	extract3
	app_global_put
	retsub

// arc72_totalSupply()uint256
//
// Returns the number of NFTs currently defined by this contract
abi_route_arc72_totalSupply:
	// execute arc72_totalSupply()uint256
	callsub arc72_totalSupply
	int 1
	return

arc72_totalSupply:
	proto 0 0

	// examples/arc72/arc72.algo.ts:106
	// return this.index.value;
	byte "index"
	app_global_get
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dupn 2
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b<=
	assert
	len
	int 32
	-
	int 32
	extract3
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// arc72_tokenByIndex(uint256)uint256
//
// Returns the token ID of the token with the given index among all NFTs defined by the contract
abi_route_arc72_tokenByIndex:
	// index: uint256
	txna ApplicationArgs 1

	// execute arc72_tokenByIndex(uint256)uint256
	callsub arc72_tokenByIndex
	int 1
	return

arc72_tokenByIndex:
	proto 1 0

	// examples/arc72/arc72.algo.ts:114
	// return index;
	frame_dig -1 // index: uint256
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dupn 2
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b<=
	assert
	len
	int 32
	-
	int 32
	extract3
	byte 0x151f7c75
	swap
	concat
	log
	retsub

abi_route_defaultTEALScriptCreate:
	int 1
	return

create_NoOp:
	txn NumAppArgs
	bz abi_route_defaultTEALScriptCreate
	err

call_NoOp:
	method "arc72_ownerOf(uint256)address"
	method "arc72_tokenURI(uint256)byte[256]"
	method "arc72_transferFrom(address,address,uint256)void"
	method "arc72_approve(address,uint256)void"
	method "arc72_setApprovalForAll(address,bool)void"
	method "mint(address)void"
	method "arc72_totalSupply()uint256"
	method "arc72_tokenByIndex(uint256)uint256"
	txna ApplicationArgs 0
	match abi_route_arc72_ownerOf abi_route_arc72_tokenURI abi_route_arc72_transferFrom abi_route_arc72_approve abi_route_arc72_setApprovalForAll abi_route_mint abi_route_arc72_totalSupply abi_route_arc72_tokenByIndex
	err