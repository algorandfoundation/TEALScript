#pragma version 10
intcblock 1

// This TEAL was generated by TEALScript v0.106.3
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// and(uint64,uint64)void
*abi_route_and:
	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute and(uint64,uint64)void
	callsub and
	intc 0 // 1
	return

// and(a: uint64, b: uint64): void
and:
	proto 2 0

	// tests/contracts/binary.algo.ts:6
	// assert(a && b)
	frame_dig -1 // a: uint64
	dup
	bz *skip_and0
	frame_dig -2 // b: uint64
	&&

*skip_and0:
	assert
	retsub

// or(uint64,uint64)void
*abi_route_or:
	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute or(uint64,uint64)void
	callsub or
	intc 0 // 1
	return

// or(a: uint64, b: uint64): void
or:
	proto 2 0

	// tests/contracts/binary.algo.ts:10
	// assert(a || b)
	frame_dig -1 // a: uint64
	dup
	bnz *skip_or0
	frame_dig -2 // b: uint64
	||

*skip_or0:
	assert
	retsub

// equal(uint64,uint64)void
*abi_route_equal:
	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute equal(uint64,uint64)void
	callsub equal
	intc 0 // 1
	return

// equal(a: uint64, b: uint64): void
equal:
	proto 2 0

	// tests/contracts/binary.algo.ts:14
	// assert(a === b)
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	==
	assert
	retsub

// notEqual(uint64,uint64)void
*abi_route_notEqual:
	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute notEqual(uint64,uint64)void
	callsub notEqual
	intc 0 // 1
	return

// notEqual(a: uint64, b: uint64): void
notEqual:
	proto 2 0

	// tests/contracts/binary.algo.ts:18
	// assert(a !== b)
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	!=
	assert
	retsub

// bitAnd(uint64,uint64)void
*abi_route_bitAnd:
	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bitAnd(uint64,uint64)void
	callsub bitAnd
	intc 0 // 1
	return

// bitAnd(a: uint64, b: uint64): void
bitAnd:
	proto 2 0

	// tests/contracts/binary.algo.ts:22
	// assert(a & b)
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	&
	assert
	retsub

// bitOr(uint64,uint64)void
*abi_route_bitOr:
	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bitOr(uint64,uint64)void
	callsub bitOr
	intc 0 // 1
	return

// bitOr(a: uint64, b: uint64): void
bitOr:
	proto 2 0

	// tests/contracts/binary.algo.ts:26
	// assert(a | b)
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	|
	assert
	retsub

// bitXor(uint64,uint64)void
*abi_route_bitXor:
	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bitXor(uint64,uint64)void
	callsub bitXor
	intc 0 // 1
	return

// bitXor(a: uint64, b: uint64): void
bitXor:
	proto 2 0

	// tests/contracts/binary.algo.ts:30
	// assert(a ^ b)
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	^
	assert
	retsub

// combo(uint64,uint64,uint64)void
*abi_route_combo:
	// c: uint64
	txna ApplicationArgs 3
	btoi

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute combo(uint64,uint64,uint64)void
	callsub combo
	intc 0 // 1
	return

// combo(a: uint64, b: uint64, c: uint64): void
combo:
	proto 3 0

	// tests/contracts/binary.algo.ts:34
	// assert(a || (b && c))
	frame_dig -1 // a: uint64
	dup
	bnz *skip_or1
	frame_dig -2 // b: uint64
	dup
	bz *skip_and1
	frame_dig -3 // c: uint64
	&&

*skip_and1:
	||

*skip_or1:
	assert
	retsub

// bitwiseXorOp(byte[],byte[])void
*abi_route_bitwiseXorOp:
	// b: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// a: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute bitwiseXorOp(byte[],byte[])void
	callsub bitwiseXorOp
	intc 0 // 1
	return

// bitwiseXorOp(a: bytes, b: bytes): void
bitwiseXorOp:
	proto 2 0

	// tests/contracts/binary.algo.ts:38
	// bitwiseXor(a, b)
	frame_dig -1 // a: bytes
	frame_dig -2 // b: bytes
	b^
	retsub

// bitwiseAndOp(byte[],byte[])void
*abi_route_bitwiseAndOp:
	// b: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// a: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute bitwiseAndOp(byte[],byte[])void
	callsub bitwiseAndOp
	intc 0 // 1
	return

// bitwiseAndOp(a: bytes, b: bytes): void
bitwiseAndOp:
	proto 2 0

	// tests/contracts/binary.algo.ts:42
	// bitwiseAnd(a, b)
	frame_dig -1 // a: bytes
	frame_dig -2 // b: bytes
	b&
	retsub

// bitwiseOrOp(byte[],byte[])void
*abi_route_bitwiseOrOp:
	// b: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// a: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute bitwiseOrOp(byte[],byte[])void
	callsub bitwiseOrOp
	intc 0 // 1
	return

// bitwiseOrOp(a: bytes, b: bytes): void
bitwiseOrOp:
	proto 2 0

	// tests/contracts/binary.algo.ts:46
	// bitwiseOr(a, b)
	frame_dig -1 // a: bytes
	frame_dig -2 // b: bytes
	b|
	retsub

// bitwiseNotOp(byte[])void
*abi_route_bitwiseNotOp:
	// a: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute bitwiseNotOp(byte[])void
	callsub bitwiseNotOp
	intc 0 // 1
	return

// bitwiseNotOp(a: bytes): void
bitwiseNotOp:
	proto 1 0

	// tests/contracts/binary.algo.ts:50
	// bitwiseNot(a)
	frame_dig -1 // a: bytes
	b~
	retsub

*abi_route_createApplication:
	intc 0 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x6fd13a13 // method "and(uint64,uint64)void"
	pushbytes 0x700aa887 // method "or(uint64,uint64)void"
	pushbytes 0x723c87ef // method "equal(uint64,uint64)void"
	pushbytes 0xe7ffb9d3 // method "notEqual(uint64,uint64)void"
	pushbytes 0x9285188e // method "bitAnd(uint64,uint64)void"
	pushbytes 0x592dc73f // method "bitOr(uint64,uint64)void"
	pushbytes 0x6d46504a // method "bitXor(uint64,uint64)void"
	pushbytes 0x74dc5150 // method "combo(uint64,uint64,uint64)void"
	pushbytes 0x43c2a56f // method "bitwiseXorOp(byte[],byte[])void"
	pushbytes 0xc9723e5e // method "bitwiseAndOp(byte[],byte[])void"
	pushbytes 0xffc83585 // method "bitwiseOrOp(byte[],byte[])void"
	pushbytes 0xbd6bcea7 // method "bitwiseNotOp(byte[])void"
	txna ApplicationArgs 0
	match *abi_route_and *abi_route_or *abi_route_equal *abi_route_notEqual *abi_route_bitAnd *abi_route_bitOr *abi_route_bitXor *abi_route_combo *abi_route_bitwiseXorOp *abi_route_bitwiseAndOp *abi_route_bitwiseOrOp *abi_route_bitwiseNotOp

	// this contract does not implement the given ABI method for call NoOp
	err