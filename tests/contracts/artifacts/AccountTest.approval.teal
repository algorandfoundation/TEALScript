#pragma version 10
intcblock 1 32 123

// This TEAL was generated by TEALScript v0.106.2
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// hasAsset(address)void
*abi_route_hasAsset:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for hasAsset must be a address
	assert

	// execute hasAsset(address)void
	callsub hasAsset
	intc 0 // 1
	return

// hasAsset(a: Address): void
hasAsset:
	proto 1 0

	// tests/contracts/account.algo.ts:6
	// assert(a.isOptedInToAsset(AssetID.fromUint64(123)))
	frame_dig -1 // a: Address
	intc 2 // 123
	asset_holding_get AssetBalance
	swap
	pop
	assert
	retsub

// assetBalance(address)void
*abi_route_assetBalance:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for assetBalance must be a address
	assert

	// execute assetBalance(address)void
	callsub assetBalance
	intc 0 // 1
	return

// assetBalance(a: Address): void
assetBalance:
	proto 1 0

	// tests/contracts/account.algo.ts:10
	// assert(a.assetBalance(AssetID.fromUint64(123)))
	frame_dig -1 // a: Address
	intc 2 // 123
	asset_holding_get AssetBalance
	pop
	assert
	retsub

// assetFrozen(address)void
*abi_route_assetFrozen:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for assetFrozen must be a address
	assert

	// execute assetFrozen(address)void
	callsub assetFrozen
	intc 0 // 1
	return

// assetFrozen(a: Address): void
assetFrozen:
	proto 1 0

	// tests/contracts/account.algo.ts:14
	// assert(a.assetFrozen(AssetID.fromUint64(123)))
	frame_dig -1 // a: Address
	intc 2 // 123
	asset_holding_get AssetFrozen
	pop
	assert
	retsub

// hasBalance(address)void
*abi_route_hasBalance:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for hasBalance must be a address
	assert

	// execute hasBalance(address)void
	callsub hasBalance
	intc 0 // 1
	return

// hasBalance(a: Address): void
hasBalance:
	proto 1 0

	// tests/contracts/account.algo.ts:18
	// assert(a.isInLedger)
	frame_dig -1 // a: Address
	acct_params_get AcctBalance
	swap
	pop
	assert
	retsub

// balance(address)void
*abi_route_balance:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for balance must be a address
	assert

	// execute balance(address)void
	callsub balance
	intc 0 // 1
	return

// balance(a: Address): void
balance:
	proto 1 0

	// tests/contracts/account.algo.ts:22
	// assert(a.balance)
	frame_dig -1 // a: Address
	acct_params_get AcctBalance
	pop
	assert
	retsub

// minBalance(address)void
*abi_route_minBalance:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for minBalance must be a address
	assert

	// execute minBalance(address)void
	callsub minBalance
	intc 0 // 1
	return

// minBalance(a: Address): void
minBalance:
	proto 1 0

	// tests/contracts/account.algo.ts:26
	// assert(a.minBalance)
	frame_dig -1 // a: Address
	acct_params_get AcctMinBalance
	pop
	assert
	retsub

// authAddr(address)void
*abi_route_authAddr:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for authAddr must be a address
	assert

	// execute authAddr(address)void
	callsub authAddr
	intc 0 // 1
	return

// authAddr(a: Address): void
authAddr:
	proto 1 0

	// tests/contracts/account.algo.ts:30
	// log(a.authAddr)
	frame_dig -1 // a: Address
	acct_params_get AcctAuthAddr
	pop
	log
	retsub

// totalNumUint(address)void
*abi_route_totalNumUint:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for totalNumUint must be a address
	assert

	// execute totalNumUint(address)void
	callsub totalNumUint
	intc 0 // 1
	return

// totalNumUint(a: Address): void
totalNumUint:
	proto 1 0

	// tests/contracts/account.algo.ts:34
	// assert(a.totalNumUint)
	frame_dig -1 // a: Address
	acct_params_get AcctTotalNumUint
	pop
	assert
	retsub

// totalNumByteSlice(address)void
*abi_route_totalNumByteSlice:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for totalNumByteSlice must be a address
	assert

	// execute totalNumByteSlice(address)void
	callsub totalNumByteSlice
	intc 0 // 1
	return

// totalNumByteSlice(a: Address): void
totalNumByteSlice:
	proto 1 0

	// tests/contracts/account.algo.ts:38
	// assert(a.totalNumByteSlice)
	frame_dig -1 // a: Address
	acct_params_get AcctTotalNumByteSlice
	pop
	assert
	retsub

// totalExtraAppPages(address)void
*abi_route_totalExtraAppPages:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for totalExtraAppPages must be a address
	assert

	// execute totalExtraAppPages(address)void
	callsub totalExtraAppPages
	intc 0 // 1
	return

// totalExtraAppPages(a: Address): void
totalExtraAppPages:
	proto 1 0

	// tests/contracts/account.algo.ts:42
	// assert(a.totalExtraAppPages)
	frame_dig -1 // a: Address
	acct_params_get AcctTotalExtraAppPages
	pop
	assert
	retsub

// totalAppsCreated(address)void
*abi_route_totalAppsCreated:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for totalAppsCreated must be a address
	assert

	// execute totalAppsCreated(address)void
	callsub totalAppsCreated
	intc 0 // 1
	return

// totalAppsCreated(a: Address): void
totalAppsCreated:
	proto 1 0

	// tests/contracts/account.algo.ts:46
	// assert(a.totalAppsCreated)
	frame_dig -1 // a: Address
	acct_params_get AcctTotalAppsCreated
	pop
	assert
	retsub

// totalAppsOptedIn(address)void
*abi_route_totalAppsOptedIn:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for totalAppsOptedIn must be a address
	assert

	// execute totalAppsOptedIn(address)void
	callsub totalAppsOptedIn
	intc 0 // 1
	return

// totalAppsOptedIn(a: Address): void
totalAppsOptedIn:
	proto 1 0

	// tests/contracts/account.algo.ts:50
	// assert(a.totalAppsOptedIn)
	frame_dig -1 // a: Address
	acct_params_get AcctTotalAppsOptedIn
	pop
	assert
	retsub

// totalAssetsCreated(address)void
*abi_route_totalAssetsCreated:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for totalAssetsCreated must be a address
	assert

	// execute totalAssetsCreated(address)void
	callsub totalAssetsCreated
	intc 0 // 1
	return

// totalAssetsCreated(a: Address): void
totalAssetsCreated:
	proto 1 0

	// tests/contracts/account.algo.ts:54
	// assert(a.totalAssetsCreated)
	frame_dig -1 // a: Address
	acct_params_get AcctTotalAssetsCreated
	pop
	assert
	retsub

// totalAssets(address)void
*abi_route_totalAssets:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for totalAssets must be a address
	assert

	// execute totalAssets(address)void
	callsub totalAssets
	intc 0 // 1
	return

// totalAssets(a: Address): void
totalAssets:
	proto 1 0

	// tests/contracts/account.algo.ts:58
	// assert(a.totalAssets)
	frame_dig -1 // a: Address
	acct_params_get AcctTotalAssets
	pop
	assert
	retsub

// totalBoxes(address)void
*abi_route_totalBoxes:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for totalBoxes must be a address
	assert

	// execute totalBoxes(address)void
	callsub totalBoxes
	intc 0 // 1
	return

// totalBoxes(a: Address): void
totalBoxes:
	proto 1 0

	// tests/contracts/account.algo.ts:62
	// assert(a.totalBoxes)
	frame_dig -1 // a: Address
	acct_params_get AcctTotalBoxes
	pop
	assert
	retsub

// totalBoxBytes(address)void
*abi_route_totalBoxBytes:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for totalBoxBytes must be a address
	assert

	// execute totalBoxBytes(address)void
	callsub totalBoxBytes
	intc 0 // 1
	return

// totalBoxBytes(a: Address): void
totalBoxBytes:
	proto 1 0

	// tests/contracts/account.algo.ts:66
	// assert(a.totalBoxBytes)
	frame_dig -1 // a: Address
	acct_params_get AcctTotalBoxBytes
	pop
	assert
	retsub

*abi_route_createApplication:
	intc 0 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xaa38ae91 // method "hasAsset(address)void"
	pushbytes 0x64cb0661 // method "assetBalance(address)void"
	pushbytes 0x68d18ddb // method "assetFrozen(address)void"
	pushbytes 0x2abf1ede // method "hasBalance(address)void"
	pushbytes 0x899e479d // method "balance(address)void"
	pushbytes 0x258a0fca // method "minBalance(address)void"
	pushbytes 0xbecc2183 // method "authAddr(address)void"
	pushbytes 0xfb81e109 // method "totalNumUint(address)void"
	pushbytes 0x44d215e1 // method "totalNumByteSlice(address)void"
	pushbytes 0x4b3bfef3 // method "totalExtraAppPages(address)void"
	pushbytes 0x091ad2aa // method "totalAppsCreated(address)void"
	pushbytes 0xb9bf3f95 // method "totalAppsOptedIn(address)void"
	pushbytes 0x4f8d2d2c // method "totalAssetsCreated(address)void"
	pushbytes 0x13d4a37d // method "totalAssets(address)void"
	pushbytes 0xfc8723da // method "totalBoxes(address)void"
	pushbytes 0xc4cc5e95 // method "totalBoxBytes(address)void"
	txna ApplicationArgs 0
	match *abi_route_hasAsset *abi_route_assetBalance *abi_route_assetFrozen *abi_route_hasBalance *abi_route_balance *abi_route_minBalance *abi_route_authAddr *abi_route_totalNumUint *abi_route_totalNumByteSlice *abi_route_totalExtraAppPages *abi_route_totalAppsCreated *abi_route_totalAppsOptedIn *abi_route_totalAssetsCreated *abi_route_totalAssets *abi_route_totalBoxes *abi_route_totalBoxBytes

	// this contract does not implement the given ABI method for call NoOp
	err