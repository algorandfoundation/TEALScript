#pragma version 10

// This TEAL was generated by TEALScript v0.97.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// hasAsset(address)void
*abi_route_hasAsset:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for hasAsset must be a address
	assert

	// execute hasAsset(address)void
	callsub hasAsset
	int 1
	return

// hasAsset(a: Address): void
hasAsset:
	proto 1 0

	// tests/contracts/account.algo.ts:6
	// assert(a.isOptedInToAsset(AssetID.fromUint64(123)))
	frame_dig -1 // a: Address
	int 123
	asset_holding_get AssetBalance
	swap
	pop
	assert
	retsub

// assetBalance(address)void
*abi_route_assetBalance:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for assetBalance must be a address
	assert

	// execute assetBalance(address)void
	callsub assetBalance
	int 1
	return

// assetBalance(a: Address): void
assetBalance:
	proto 1 0

	// tests/contracts/account.algo.ts:10
	// assert(a.assetBalance(AssetID.fromUint64(123)))
	frame_dig -1 // a: Address
	int 123
	asset_holding_get AssetBalance
	pop
	assert
	retsub

// assetFrozen(address)void
*abi_route_assetFrozen:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for assetFrozen must be a address
	assert

	// execute assetFrozen(address)void
	callsub assetFrozen
	int 1
	return

// assetFrozen(a: Address): void
assetFrozen:
	proto 1 0

	// tests/contracts/account.algo.ts:14
	// assert(a.assetFrozen(AssetID.fromUint64(123)))
	frame_dig -1 // a: Address
	int 123
	asset_holding_get AssetFrozen
	pop
	assert
	retsub

// hasBalance(address)void
*abi_route_hasBalance:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for hasBalance must be a address
	assert

	// execute hasBalance(address)void
	callsub hasBalance
	int 1
	return

// hasBalance(a: Address): void
hasBalance:
	proto 1 0

	// tests/contracts/account.algo.ts:18
	// assert(a.isInLedger)
	frame_dig -1 // a: Address
	acct_params_get AcctBalance
	swap
	pop
	assert
	retsub

// balance(address)void
*abi_route_balance:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for balance must be a address
	assert

	// execute balance(address)void
	callsub balance
	int 1
	return

// balance(a: Address): void
balance:
	proto 1 0

	// tests/contracts/account.algo.ts:22
	// assert(a.balance)
	frame_dig -1 // a: Address
	acct_params_get AcctBalance
	pop
	assert
	retsub

// minBalance(address)void
*abi_route_minBalance:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for minBalance must be a address
	assert

	// execute minBalance(address)void
	callsub minBalance
	int 1
	return

// minBalance(a: Address): void
minBalance:
	proto 1 0

	// tests/contracts/account.algo.ts:26
	// assert(a.minBalance)
	frame_dig -1 // a: Address
	acct_params_get AcctMinBalance
	pop
	assert
	retsub

// authAddr(address)void
*abi_route_authAddr:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for authAddr must be a address
	assert

	// execute authAddr(address)void
	callsub authAddr
	int 1
	return

// authAddr(a: Address): void
authAddr:
	proto 1 0

	// tests/contracts/account.algo.ts:30
	// log(a.authAddr)
	frame_dig -1 // a: Address
	acct_params_get AcctAuthAddr
	pop
	log
	retsub

// totalNumUint(address)void
*abi_route_totalNumUint:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for totalNumUint must be a address
	assert

	// execute totalNumUint(address)void
	callsub totalNumUint
	int 1
	return

// totalNumUint(a: Address): void
totalNumUint:
	proto 1 0

	// tests/contracts/account.algo.ts:34
	// assert(a.totalNumUint)
	frame_dig -1 // a: Address
	acct_params_get AcctTotalNumUint
	pop
	assert
	retsub

// totalNumByteSlice(address)void
*abi_route_totalNumByteSlice:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for totalNumByteSlice must be a address
	assert

	// execute totalNumByteSlice(address)void
	callsub totalNumByteSlice
	int 1
	return

// totalNumByteSlice(a: Address): void
totalNumByteSlice:
	proto 1 0

	// tests/contracts/account.algo.ts:38
	// assert(a.totalNumByteSlice)
	frame_dig -1 // a: Address
	acct_params_get AcctTotalNumByteSlice
	pop
	assert
	retsub

// totalExtraAppPages(address)void
*abi_route_totalExtraAppPages:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for totalExtraAppPages must be a address
	assert

	// execute totalExtraAppPages(address)void
	callsub totalExtraAppPages
	int 1
	return

// totalExtraAppPages(a: Address): void
totalExtraAppPages:
	proto 1 0

	// tests/contracts/account.algo.ts:42
	// assert(a.totalExtraAppPages)
	frame_dig -1 // a: Address
	acct_params_get AcctTotalExtraAppPages
	pop
	assert
	retsub

// totalAppsCreated(address)void
*abi_route_totalAppsCreated:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for totalAppsCreated must be a address
	assert

	// execute totalAppsCreated(address)void
	callsub totalAppsCreated
	int 1
	return

// totalAppsCreated(a: Address): void
totalAppsCreated:
	proto 1 0

	// tests/contracts/account.algo.ts:46
	// assert(a.totalAppsCreated)
	frame_dig -1 // a: Address
	acct_params_get AcctTotalAppsCreated
	pop
	assert
	retsub

// totalAppsOptedIn(address)void
*abi_route_totalAppsOptedIn:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for totalAppsOptedIn must be a address
	assert

	// execute totalAppsOptedIn(address)void
	callsub totalAppsOptedIn
	int 1
	return

// totalAppsOptedIn(a: Address): void
totalAppsOptedIn:
	proto 1 0

	// tests/contracts/account.algo.ts:50
	// assert(a.totalAppsOptedIn)
	frame_dig -1 // a: Address
	acct_params_get AcctTotalAppsOptedIn
	pop
	assert
	retsub

// totalAssetsCreated(address)void
*abi_route_totalAssetsCreated:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for totalAssetsCreated must be a address
	assert

	// execute totalAssetsCreated(address)void
	callsub totalAssetsCreated
	int 1
	return

// totalAssetsCreated(a: Address): void
totalAssetsCreated:
	proto 1 0

	// tests/contracts/account.algo.ts:54
	// assert(a.totalAssetsCreated)
	frame_dig -1 // a: Address
	acct_params_get AcctTotalAssetsCreated
	pop
	assert
	retsub

// totalAssets(address)void
*abi_route_totalAssets:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for totalAssets must be a address
	assert

	// execute totalAssets(address)void
	callsub totalAssets
	int 1
	return

// totalAssets(a: Address): void
totalAssets:
	proto 1 0

	// tests/contracts/account.algo.ts:58
	// assert(a.totalAssets)
	frame_dig -1 // a: Address
	acct_params_get AcctTotalAssets
	pop
	assert
	retsub

// totalBoxes(address)void
*abi_route_totalBoxes:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for totalBoxes must be a address
	assert

	// execute totalBoxes(address)void
	callsub totalBoxes
	int 1
	return

// totalBoxes(a: Address): void
totalBoxes:
	proto 1 0

	// tests/contracts/account.algo.ts:62
	// assert(a.totalBoxes)
	frame_dig -1 // a: Address
	acct_params_get AcctTotalBoxes
	pop
	assert
	retsub

// totalBoxBytes(address)void
*abi_route_totalBoxBytes:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for totalBoxBytes must be a address
	assert

	// execute totalBoxBytes(address)void
	callsub totalBoxBytes
	int 1
	return

// totalBoxBytes(a: Address): void
totalBoxBytes:
	proto 1 0

	// tests/contracts/account.algo.ts:66
	// assert(a.totalBoxBytes)
	frame_dig -1 // a: Address
	acct_params_get AcctTotalBoxBytes
	pop
	assert
	retsub

*abi_route_createApplication:
	int 1
	return

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "hasAsset(address)void"
	method "assetBalance(address)void"
	method "assetFrozen(address)void"
	method "hasBalance(address)void"
	method "balance(address)void"
	method "minBalance(address)void"
	method "authAddr(address)void"
	method "totalNumUint(address)void"
	method "totalNumByteSlice(address)void"
	method "totalExtraAppPages(address)void"
	method "totalAppsCreated(address)void"
	method "totalAppsOptedIn(address)void"
	method "totalAssetsCreated(address)void"
	method "totalAssets(address)void"
	method "totalBoxes(address)void"
	method "totalBoxBytes(address)void"
	txna ApplicationArgs 0
	match *abi_route_hasAsset *abi_route_assetBalance *abi_route_assetFrozen *abi_route_hasBalance *abi_route_balance *abi_route_minBalance *abi_route_authAddr *abi_route_totalNumUint *abi_route_totalNumByteSlice *abi_route_totalExtraAppPages *abi_route_totalAppsCreated *abi_route_totalAppsOptedIn *abi_route_totalAssetsCreated *abi_route_totalAssets *abi_route_totalBoxes *abi_route_totalBoxBytes

	// this contract does not implement the given ABI method for call NoOp
	err