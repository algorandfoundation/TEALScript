#pragma version 10

// This TEAL was generated by TEALScript v0.94.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// prefix()void
*abi_route_prefix:
	// execute prefix()void
	callsub prefix
	int 1
	return

// prefix(): void
prefix:
	proto 0 0

	// tests/contracts/storage.algo.ts:26
	// this.boxMapWithPrefix('oo').value = 'bar'
	byte 0x666f6f
	dup
	box_del
	pop
	byte 0x626172 // "bar"
	box_put

	// tests/contracts/storage.algo.ts:27
	// this.globalMapWithPrefix('oo').value = 'bar'
	byte 0x666f6f
	byte 0x626172 // "bar"
	app_global_put

	// tests/contracts/storage.algo.ts:28
	// this.localMapWithPrefix(this.txn.sender, 'oo').value = 'bar'
	txn Sender
	byte 0x666f6f
	byte 0x626172 // "bar"
	app_local_put
	retsub

// globalKeyPut()void
*abi_route_globalKeyPut:
	// execute globalKeyPut()void
	callsub globalKeyPut
	int 1
	return

// globalKeyPut(): void
globalKeyPut:
	proto 0 0

	// tests/contracts/storage.algo.ts:32
	// this.globalKey.value = 'bar'
	byte 0x666f6f // "foo"
	byte 0x626172 // "bar"
	app_global_put
	retsub

// globalKeyGet()void
*abi_route_globalKeyGet:
	// execute globalKeyGet()void
	callsub globalKeyGet
	int 1
	return

// globalKeyGet(): void
globalKeyGet:
	proto 0 0

	// tests/contracts/storage.algo.ts:36
	// assert(this.globalKey.value === 'bar')
	byte 0x666f6f // "foo"
	app_global_get
	byte 0x626172 // "bar"
	==
	assert
	retsub

// globalKeyDelete()void
*abi_route_globalKeyDelete:
	// execute globalKeyDelete()void
	callsub globalKeyDelete
	int 1
	return

// globalKeyDelete(): void
globalKeyDelete:
	proto 0 0

	// tests/contracts/storage.algo.ts:40
	// this.globalKey.delete()
	byte 0x666f6f // "foo"
	app_global_del
	retsub

// globalKeyExists()void
*abi_route_globalKeyExists:
	// execute globalKeyExists()void
	callsub globalKeyExists
	int 1
	return

// globalKeyExists(): void
globalKeyExists:
	proto 0 0

	// tests/contracts/storage.algo.ts:44
	// assert(this.globalKey.exists)
	txna Applications 0
	byte 0x666f6f // "foo"
	app_global_get_ex
	swap
	pop
	assert
	retsub

// localKeyPut(address)void
*abi_route_localKeyPut:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for localKeyPut must be a address
	assert

	// execute localKeyPut(address)void
	callsub localKeyPut
	int 1
	return

// localKeyPut(a: Address): void
localKeyPut:
	proto 1 0

	// tests/contracts/storage.algo.ts:48
	// this.localKey(a).value = 'bar'
	frame_dig -1 // a: Address
	byte 0x666f6f // "foo"
	byte 0x626172 // "bar"
	app_local_put
	retsub

// localKeyGet(address)void
*abi_route_localKeyGet:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for localKeyGet must be a address
	assert

	// execute localKeyGet(address)void
	callsub localKeyGet
	int 1
	return

// localKeyGet(a: Address): void
localKeyGet:
	proto 1 0

	// tests/contracts/storage.algo.ts:52
	// assert(this.localKey(a).value === 'bar')
	frame_dig -1 // a: Address
	byte 0x666f6f // "foo"
	app_local_get
	byte 0x626172 // "bar"
	==
	assert
	retsub

// localKeyDelete(address)void
*abi_route_localKeyDelete:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for localKeyDelete must be a address
	assert

	// execute localKeyDelete(address)void
	callsub localKeyDelete
	int 1
	return

// localKeyDelete(a: Address): void
localKeyDelete:
	proto 1 0

	// tests/contracts/storage.algo.ts:56
	// this.localKey(a).delete()
	frame_dig -1 // a: Address
	byte 0x666f6f // "foo"
	app_local_del
	retsub

// localKeyExists(address)void
*abi_route_localKeyExists:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for localKeyExists must be a address
	assert

	// execute localKeyExists(address)void
	callsub localKeyExists
	int 1
	return

// localKeyExists(a: Address): void
localKeyExists:
	proto 1 0

	// tests/contracts/storage.algo.ts:60
	// assert(this.localKey(a).exists)
	frame_dig -1 // a: Address
	txna Applications 0
	byte 0x666f6f // "foo"
	app_local_get_ex
	swap
	pop
	assert
	retsub

// boxKeyPut()void
*abi_route_boxKeyPut:
	// execute boxKeyPut()void
	callsub boxKeyPut
	int 1
	return

// boxKeyPut(): void
boxKeyPut:
	proto 0 0

	// tests/contracts/storage.algo.ts:64
	// this.boxKey.value = 'bar'
	byte 0x666f6f // "foo"
	byte 0x626172 // "bar"
	box_put
	retsub

// boxKeyGet()void
*abi_route_boxKeyGet:
	// execute boxKeyGet()void
	callsub boxKeyGet
	int 1
	return

// boxKeyGet(): void
boxKeyGet:
	proto 0 0

	// tests/contracts/storage.algo.ts:68
	// assert(this.boxKey.value === 'bar')
	byte 0x666f6f // "foo"
	box_get

	// box value does not exist: this.boxKey.value
	assert
	byte 0x626172 // "bar"
	==
	assert
	retsub

// boxKeyDelete()void
*abi_route_boxKeyDelete:
	// execute boxKeyDelete()void
	callsub boxKeyDelete
	int 1
	return

// boxKeyDelete(): void
boxKeyDelete:
	proto 0 0

	// tests/contracts/storage.algo.ts:72
	// this.boxKey.delete()
	byte 0x666f6f // "foo"
	box_del
	retsub

// boxKeyExists()void
*abi_route_boxKeyExists:
	// execute boxKeyExists()void
	callsub boxKeyExists
	int 1
	return

// boxKeyExists(): void
boxKeyExists:
	proto 0 0

	// tests/contracts/storage.algo.ts:76
	// assert(this.boxKey.exists)
	byte 0x666f6f // "foo"
	box_len
	swap
	pop
	assert
	retsub

// globalMapPut()void
*abi_route_globalMapPut:
	// execute globalMapPut()void
	callsub globalMapPut
	int 1
	return

// globalMapPut(): void
globalMapPut:
	proto 0 0

	// tests/contracts/storage.algo.ts:80
	// this.globalMap('foo').value = 'bar'
	byte 0x666f6f // "foo"
	byte 0x626172 // "bar"
	app_global_put
	retsub

// globalMapGet()void
*abi_route_globalMapGet:
	// execute globalMapGet()void
	callsub globalMapGet
	int 1
	return

// globalMapGet(): void
globalMapGet:
	proto 0 0

	// tests/contracts/storage.algo.ts:84
	// assert(this.globalMap('foo').value === 'bar')
	byte 0x666f6f // "foo"
	app_global_get
	byte 0x626172 // "bar"
	==
	assert
	retsub

// globalMapDelete()void
*abi_route_globalMapDelete:
	// execute globalMapDelete()void
	callsub globalMapDelete
	int 1
	return

// globalMapDelete(): void
globalMapDelete:
	proto 0 0

	// tests/contracts/storage.algo.ts:88
	// this.globalMap('foo').delete()
	byte 0x666f6f // "foo"
	app_global_del
	retsub

// globalMapExists()void
*abi_route_globalMapExists:
	// execute globalMapExists()void
	callsub globalMapExists
	int 1
	return

// globalMapExists(): void
globalMapExists:
	proto 0 0

	// tests/contracts/storage.algo.ts:92
	// assert(this.globalMap('foo').exists)
	txna Applications 0
	byte 0x666f6f // "foo"
	app_global_get_ex
	swap
	pop
	assert
	retsub

// localMapPut(address)void
*abi_route_localMapPut:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for localMapPut must be a address
	assert

	// execute localMapPut(address)void
	callsub localMapPut
	int 1
	return

// localMapPut(a: Address): void
localMapPut:
	proto 1 0

	// tests/contracts/storage.algo.ts:96
	// this.localMap(a, 'foo').value = 'bar'
	frame_dig -1 // a: Address
	byte 0x666f6f // "foo"
	byte 0x626172 // "bar"
	app_local_put
	retsub

// localMapGet(address)void
*abi_route_localMapGet:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for localMapGet must be a address
	assert

	// execute localMapGet(address)void
	callsub localMapGet
	int 1
	return

// localMapGet(a: Address): void
localMapGet:
	proto 1 0

	// tests/contracts/storage.algo.ts:100
	// assert(this.localMap(a, 'foo').value === 'bar')
	frame_dig -1 // a: Address
	byte 0x666f6f // "foo"
	app_local_get
	byte 0x626172 // "bar"
	==
	assert
	retsub

// localMapDelete(address)void
*abi_route_localMapDelete:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for localMapDelete must be a address
	assert

	// execute localMapDelete(address)void
	callsub localMapDelete
	int 1
	return

// localMapDelete(a: Address): void
localMapDelete:
	proto 1 0

	// tests/contracts/storage.algo.ts:104
	// this.localMap(a, 'foo').delete()
	frame_dig -1 // a: Address
	byte 0x666f6f // "foo"
	app_local_del
	retsub

// localMapExists(address)void
*abi_route_localMapExists:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (a) for localMapExists must be a address
	assert

	// execute localMapExists(address)void
	callsub localMapExists
	int 1
	return

// localMapExists(a: Address): void
localMapExists:
	proto 1 0

	// tests/contracts/storage.algo.ts:108
	// assert(this.localMap(a, 'foo').exists)
	frame_dig -1 // a: Address
	txna Applications 0
	byte 0x666f6f // "foo"
	app_local_get_ex
	swap
	pop
	assert
	retsub

// boxMapPut()void
*abi_route_boxMapPut:
	// execute boxMapPut()void
	callsub boxMapPut
	int 1
	return

// boxMapPut(): void
boxMapPut:
	proto 0 0

	// tests/contracts/storage.algo.ts:112
	// this.boxMap('foo').value = 'bar'
	byte 0x666f6f // "foo"
	byte 0x626172 // "bar"
	box_put
	retsub

// boxMapGet()void
*abi_route_boxMapGet:
	// execute boxMapGet()void
	callsub boxMapGet
	int 1
	return

// boxMapGet(): void
boxMapGet:
	proto 0 0

	// tests/contracts/storage.algo.ts:116
	// assert(this.boxMap('foo').value === 'bar')
	byte 0x666f6f // "foo"
	box_get

	// box value does not exist: this.boxMap('foo').value
	assert
	byte 0x626172 // "bar"
	==
	assert
	retsub

// boxMapDelete()void
*abi_route_boxMapDelete:
	// execute boxMapDelete()void
	callsub boxMapDelete
	int 1
	return

// boxMapDelete(): void
boxMapDelete:
	proto 0 0

	// tests/contracts/storage.algo.ts:120
	// this.boxMap('foo').delete()
	byte 0x666f6f // "foo"
	box_del
	retsub

// boxMapExists()void
*abi_route_boxMapExists:
	// execute boxMapExists()void
	callsub boxMapExists
	int 1
	return

// boxMapExists(): void
boxMapExists:
	proto 0 0

	// tests/contracts/storage.algo.ts:124
	// assert(this.boxMap('foo').exists)
	byte 0x666f6f // "foo"
	box_len
	swap
	pop
	assert
	retsub

// boxKeyCreate()void
*abi_route_boxKeyCreate:
	// execute boxKeyCreate()void
	callsub boxKeyCreate
	int 1
	return

// boxKeyCreate(): void
boxKeyCreate:
	proto 0 0

	// tests/contracts/storage.algo.ts:128
	// this.boxKey.create(1024)
	byte 0x666f6f // "foo"
	int 1024
	box_create
	pop
	retsub

// boxMapCreate()void
*abi_route_boxMapCreate:
	// execute boxMapCreate()void
	callsub boxMapCreate
	int 1
	return

// boxMapCreate(): void
boxMapCreate:
	proto 0 0

	// tests/contracts/storage.algo.ts:132
	// this.boxMap('bar').create(1024)
	byte 0x626172 // "bar"
	int 1024
	box_create
	pop
	retsub

// boxKeyLength()uint64
*abi_route_boxKeyLength:
	// The ABI return prefix
	byte 0x151f7c75

	// execute boxKeyLength()uint64
	callsub boxKeyLength
	itob
	concat
	log
	int 1
	return

// boxKeyLength(): uint64
boxKeyLength:
	proto 0 1

	// tests/contracts/storage.algo.ts:136
	// return this.boxKey.size;
	byte 0x666f6f // "foo"
	box_len

	// box value does not exist: this.boxKey.size
	assert
	retsub

// boxMapLength()uint64
*abi_route_boxMapLength:
	// The ABI return prefix
	byte 0x151f7c75

	// execute boxMapLength()uint64
	callsub boxMapLength
	itob
	concat
	log
	int 1
	return

// boxMapLength(): uint64
boxMapLength:
	proto 0 1

	// tests/contracts/storage.algo.ts:140
	// return this.boxMap('bar').size;
	byte 0x626172 // "bar"
	box_len

	// box value does not exist: this.boxMap('bar').size
	assert
	retsub

// boxKeyReplace()void
*abi_route_boxKeyReplace:
	// execute boxKeyReplace()void
	callsub boxKeyReplace
	int 1
	return

// boxKeyReplace(): void
boxKeyReplace:
	proto 0 0

	// tests/contracts/storage.algo.ts:144
	// this.boxKey.replace(0, 'abc')
	byte 0x666f6f // "foo"
	int 0
	byte 0x616263 // "abc"
	box_replace
	retsub

// boxMapReplace()void
*abi_route_boxMapReplace:
	// execute boxMapReplace()void
	callsub boxMapReplace
	int 1
	return

// boxMapReplace(): void
boxMapReplace:
	proto 0 0

	// tests/contracts/storage.algo.ts:148
	// this.boxMap('bar').replace(0, 'abc')
	byte 0x626172 // "bar"
	int 0
	byte 0x616263 // "abc"
	box_replace
	retsub

// boxKeyExtract()string
*abi_route_boxKeyExtract:
	// The ABI return prefix
	byte 0x151f7c75

	// execute boxKeyExtract()string
	callsub boxKeyExtract
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// boxKeyExtract(): string
boxKeyExtract:
	proto 0 1

	// tests/contracts/storage.algo.ts:152
	// return this.boxKey.extract(0, 3);
	byte 0x666f6f // "foo"
	int 0
	int 3
	box_extract
	retsub

// boxMapExtract()string
*abi_route_boxMapExtract:
	// The ABI return prefix
	byte 0x151f7c75

	// execute boxMapExtract()string
	callsub boxMapExtract
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// boxMapExtract(): string
boxMapExtract:
	proto 0 1

	// tests/contracts/storage.algo.ts:156
	// return this.boxMap('bar').extract(0, 3);
	byte 0x626172 // "bar"
	int 0
	int 3
	box_extract
	retsub

// isOptedIn()bool
*abi_route_isOptedIn:
	// The ABI return prefix
	byte 0x151f7c75

	// execute isOptedIn()bool
	callsub isOptedIn
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// isOptedIn(): boolean
isOptedIn:
	proto 0 1

	// tests/contracts/storage.algo.ts:160
	// return this.txn.sender.isOptedInToApp(this.app);
	txn Sender
	txna Applications 0
	app_opted_in
	retsub

// exGlobal()void
*abi_route_exGlobal:
	// execute exGlobal()void
	callsub exGlobal
	int 1
	return

// exGlobal(): void
exGlobal:
	proto 0 0

	// tests/contracts/storage.algo.ts:164
	// log(this.app.globalState('foo') as bytes)
	txna Applications 0
	byte 0x666f6f // "foo"
	app_global_get_ex

	// global state value does not exist: this.app.globalState('foo')
	assert
	log
	retsub

// exLocal()void
*abi_route_exLocal:
	// execute exLocal()void
	callsub exLocal
	int 1
	return

// exLocal(): void
exLocal:
	proto 0 0

	// tests/contracts/storage.algo.ts:168
	// log(this.app.localState(this.txn.sender, 'foo') as bytes)
	txn Sender
	txna Applications 0
	byte 0x666f6f // "foo"
	app_local_get_ex

	// local state value does not exist: this.app.localState(this.txn.sender, 'foo')
	assert
	log
	retsub

// accessStaticValueInLargeBox()uint16
*abi_route_accessStaticValueInLargeBox:
	// The ABI return prefix
	byte 0x151f7c75

	// execute accessStaticValueInLargeBox()uint16
	callsub accessStaticValueInLargeBox
	itob
	dup
	bitlen
	int 16
	<=

	// accessStaticValueInLargeBox return value overflowed 16 bits
	assert
	extract 6 2
	concat
	log
	int 1
	return

// accessStaticValueInLargeBox(): uint16
accessStaticValueInLargeBox:
	proto 0 1

	// tests/contracts/storage.algo.ts:172
	// this.largeStaticArrayInBox.create()
	byte 0x6c617267655374617469634172726179496e426f78 // "largeStaticArrayInBox"
	int 8000
	box_create
	pop

	// tests/contracts/storage.algo.ts:173
	// this.largeStaticArrayInBox.value[123] = 456
	byte 0x6c617267655374617469634172726179496e426f78 // "largeStaticArrayInBox"
	int 246
	byte 0x01c8
	box_replace

	// tests/contracts/storage.algo.ts:175
	// return this.largeStaticArrayInBox.value[123];
	byte 0x6c617267655374617469634172726179496e426f78 // "largeStaticArrayInBox"
	int 246
	int 2
	box_extract
	btoi
	retsub

// dynamicAccessStaticValueInLargeBox(uint64)uint16
*abi_route_dynamicAccessStaticValueInLargeBox:
	// The ABI return prefix
	byte 0x151f7c75

	// i: uint64
	txna ApplicationArgs 1
	btoi

	// execute dynamicAccessStaticValueInLargeBox(uint64)uint16
	callsub dynamicAccessStaticValueInLargeBox
	itob
	dup
	bitlen
	int 16
	<=

	// dynamicAccessStaticValueInLargeBox return value overflowed 16 bits
	assert
	extract 6 2
	concat
	log
	int 1
	return

// dynamicAccessStaticValueInLargeBox(i: uint64): uint16
dynamicAccessStaticValueInLargeBox:
	proto 1 1

	// tests/contracts/storage.algo.ts:179
	// this.largeStaticArrayInBox.create()
	byte 0x6c617267655374617469634172726179496e426f78 // "largeStaticArrayInBox"
	int 8000
	box_create
	pop

	// tests/contracts/storage.algo.ts:180
	// this.largeStaticArrayInBox.value[i] = 456
	frame_dig -1 // i: uint64
	int 2
	* // acc * typeLength
	byte 0x01c8
	byte 0x6c617267655374617469634172726179496e426f78 // "largeStaticArrayInBox"
	cover 2
	box_replace

	// tests/contracts/storage.algo.ts:184
	// return a[i];
	frame_dig -1 // i: uint64
	int 2
	* // acc * typeLength
	int 2
	byte 0x6c617267655374617469634172726179496e426f78 // "largeStaticArrayInBox"
	cover 2
	box_extract
	btoi
	retsub

// boxResize()void
*abi_route_boxResize:
	// execute boxResize()void
	callsub boxResize
	int 1
	return

// boxResize(): void
boxResize:
	proto 0 0

	// tests/contracts/storage.algo.ts:188
	// this.boxKey.resize(1024)
	byte 0x666f6f // "foo"
	int 1024
	box_resize

	// tests/contracts/storage.algo.ts:189
	// this.boxMap('bar').resize(1024)
	byte 0x626172 // "bar"
	int 1024
	box_resize
	retsub

// boxSplice()void
*abi_route_boxSplice:
	// execute boxSplice()void
	callsub boxSplice
	int 1
	return

// boxSplice(): void
boxSplice:
	proto 0 0

	// tests/contracts/storage.algo.ts:193
	// this.boxKey.splice(0, 1, 'abc')
	byte 0x666f6f // "foo"
	int 0
	int 1
	byte 0x616263 // "abc"
	box_splice

	// tests/contracts/storage.algo.ts:194
	// this.boxMap('bar').splice(0, 1, 'abc')
	byte 0x626172 // "bar"
	int 0
	int 1
	byte 0x616263 // "abc"
	box_splice
	retsub

// exStateExists()void
*abi_route_exStateExists:
	// execute exStateExists()void
	callsub exStateExists
	int 1
	return

// exStateExists(): void
exStateExists:
	proto 0 0

	// tests/contracts/storage.algo.ts:198
	// assert(this.app.globalStateExists('foo'))
	txna Applications 0
	byte 0x666f6f // "foo"
	app_global_get_ex
	swap
	pop
	assert

	// tests/contracts/storage.algo.ts:199
	// assert(this.app.localStateExists(this.txn.sender, 'foo'))
	txn Sender
	txna Applications 0
	byte 0x666f6f // "foo"
	app_local_get_ex
	swap
	pop
	assert
	retsub

*abi_route_createApplication:
	int 1
	return

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "prefix()void"
	method "globalKeyPut()void"
	method "globalKeyGet()void"
	method "globalKeyDelete()void"
	method "globalKeyExists()void"
	method "localKeyPut(address)void"
	method "localKeyGet(address)void"
	method "localKeyDelete(address)void"
	method "localKeyExists(address)void"
	method "boxKeyPut()void"
	method "boxKeyGet()void"
	method "boxKeyDelete()void"
	method "boxKeyExists()void"
	method "globalMapPut()void"
	method "globalMapGet()void"
	method "globalMapDelete()void"
	method "globalMapExists()void"
	method "localMapPut(address)void"
	method "localMapGet(address)void"
	method "localMapDelete(address)void"
	method "localMapExists(address)void"
	method "boxMapPut()void"
	method "boxMapGet()void"
	method "boxMapDelete()void"
	method "boxMapExists()void"
	method "boxKeyCreate()void"
	method "boxMapCreate()void"
	method "boxKeyLength()uint64"
	method "boxMapLength()uint64"
	method "boxKeyReplace()void"
	method "boxMapReplace()void"
	method "boxKeyExtract()string"
	method "boxMapExtract()string"
	method "isOptedIn()bool"
	method "exGlobal()void"
	method "exLocal()void"
	method "accessStaticValueInLargeBox()uint16"
	method "dynamicAccessStaticValueInLargeBox(uint64)uint16"
	method "boxResize()void"
	method "boxSplice()void"
	method "exStateExists()void"
	txna ApplicationArgs 0
	match *abi_route_prefix *abi_route_globalKeyPut *abi_route_globalKeyGet *abi_route_globalKeyDelete *abi_route_globalKeyExists *abi_route_localKeyPut *abi_route_localKeyGet *abi_route_localKeyDelete *abi_route_localKeyExists *abi_route_boxKeyPut *abi_route_boxKeyGet *abi_route_boxKeyDelete *abi_route_boxKeyExists *abi_route_globalMapPut *abi_route_globalMapGet *abi_route_globalMapDelete *abi_route_globalMapExists *abi_route_localMapPut *abi_route_localMapGet *abi_route_localMapDelete *abi_route_localMapExists *abi_route_boxMapPut *abi_route_boxMapGet *abi_route_boxMapDelete *abi_route_boxMapExists *abi_route_boxKeyCreate *abi_route_boxMapCreate *abi_route_boxKeyLength *abi_route_boxMapLength *abi_route_boxKeyReplace *abi_route_boxMapReplace *abi_route_boxKeyExtract *abi_route_boxMapExtract *abi_route_isOptedIn *abi_route_exGlobal *abi_route_exLocal *abi_route_accessStaticValueInLargeBox *abi_route_dynamicAccessStaticValueInLargeBox *abi_route_boxResize *abi_route_boxSplice *abi_route_exStateExists

	// this contract does not implement the given ABI method for call NoOp
	err