#pragma version 10
intcblock 1 32 0 1024 2 8000 3 16 246
bytecblock 0x666f6f 0x626172 0x151f7c75 0x6c617267655374617469634172726179496e426f78 0x616263 0x01c8

// This TEAL was generated by TEALScript v0.106.3
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// prefix()void
*abi_route_prefix:
	// execute prefix()void
	callsub prefix
	intc 0 // 1
	return

// prefix(): void
prefix:
	proto 0 0

	// tests/contracts/storage.algo.ts:26
	// this.boxMapWithPrefix('oo').value = 'bar'
	bytec 0 // 0x666f6f
	dup
	box_del
	pop
	bytec 1 //  "bar"
	box_put

	// tests/contracts/storage.algo.ts:27
	// this.globalMapWithPrefix('oo').value = 'bar'
	bytec 0 // 0x666f6f
	bytec 1 //  "bar"
	app_global_put

	// tests/contracts/storage.algo.ts:28
	// this.localMapWithPrefix(this.txn.sender, 'oo').value = 'bar'
	txn Sender
	bytec 0 // 0x666f6f
	bytec 1 //  "bar"
	app_local_put
	retsub

// globalKeyPut()void
*abi_route_globalKeyPut:
	// execute globalKeyPut()void
	callsub globalKeyPut
	intc 0 // 1
	return

// globalKeyPut(): void
globalKeyPut:
	proto 0 0

	// tests/contracts/storage.algo.ts:32
	// this.globalKey.value = 'bar'
	bytec 0 //  "foo"
	bytec 1 //  "bar"
	app_global_put
	retsub

// globalKeyGet()void
*abi_route_globalKeyGet:
	// execute globalKeyGet()void
	callsub globalKeyGet
	intc 0 // 1
	return

// globalKeyGet(): void
globalKeyGet:
	proto 0 0

	// tests/contracts/storage.algo.ts:36
	// assert(this.globalKey.value === 'bar')
	bytec 0 //  "foo"
	app_global_get
	bytec 1 //  "bar"
	==
	assert
	retsub

// globalKeyDelete()void
*abi_route_globalKeyDelete:
	// execute globalKeyDelete()void
	callsub globalKeyDelete
	intc 0 // 1
	return

// globalKeyDelete(): void
globalKeyDelete:
	proto 0 0

	// tests/contracts/storage.algo.ts:40
	// this.globalKey.delete()
	bytec 0 //  "foo"
	app_global_del
	retsub

// globalKeyExists()void
*abi_route_globalKeyExists:
	// execute globalKeyExists()void
	callsub globalKeyExists
	intc 0 // 1
	return

// globalKeyExists(): void
globalKeyExists:
	proto 0 0

	// tests/contracts/storage.algo.ts:44
	// assert(this.globalKey.exists)
	txna Applications 0
	bytec 0 //  "foo"
	app_global_get_ex
	swap
	pop
	assert
	retsub

// localKeyPut(address)void
*abi_route_localKeyPut:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for localKeyPut must be a address
	assert

	// execute localKeyPut(address)void
	callsub localKeyPut
	intc 0 // 1
	return

// localKeyPut(a: Address): void
localKeyPut:
	proto 1 0

	// tests/contracts/storage.algo.ts:48
	// this.localKey(a).value = 'bar'
	frame_dig -1 // a: Address
	bytec 0 //  "foo"
	bytec 1 //  "bar"
	app_local_put
	retsub

// localKeyGet(address)void
*abi_route_localKeyGet:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for localKeyGet must be a address
	assert

	// execute localKeyGet(address)void
	callsub localKeyGet
	intc 0 // 1
	return

// localKeyGet(a: Address): void
localKeyGet:
	proto 1 0

	// tests/contracts/storage.algo.ts:52
	// assert(this.localKey(a).value === 'bar')
	frame_dig -1 // a: Address
	bytec 0 //  "foo"
	app_local_get
	bytec 1 //  "bar"
	==
	assert
	retsub

// localKeyDelete(address)void
*abi_route_localKeyDelete:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for localKeyDelete must be a address
	assert

	// execute localKeyDelete(address)void
	callsub localKeyDelete
	intc 0 // 1
	return

// localKeyDelete(a: Address): void
localKeyDelete:
	proto 1 0

	// tests/contracts/storage.algo.ts:56
	// this.localKey(a).delete()
	frame_dig -1 // a: Address
	bytec 0 //  "foo"
	app_local_del
	retsub

// localKeyExists(address)void
*abi_route_localKeyExists:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for localKeyExists must be a address
	assert

	// execute localKeyExists(address)void
	callsub localKeyExists
	intc 0 // 1
	return

// localKeyExists(a: Address): void
localKeyExists:
	proto 1 0

	// tests/contracts/storage.algo.ts:60
	// assert(this.localKey(a).exists)
	frame_dig -1 // a: Address
	txna Applications 0
	bytec 0 //  "foo"
	app_local_get_ex
	swap
	pop
	assert
	retsub

// boxKeyPut()void
*abi_route_boxKeyPut:
	// execute boxKeyPut()void
	callsub boxKeyPut
	intc 0 // 1
	return

// boxKeyPut(): void
boxKeyPut:
	proto 0 0

	// tests/contracts/storage.algo.ts:64
	// this.boxKey.value = 'bar'
	bytec 0 //  "foo"
	bytec 1 //  "bar"
	box_put
	retsub

// boxKeyGet()void
*abi_route_boxKeyGet:
	// execute boxKeyGet()void
	callsub boxKeyGet
	intc 0 // 1
	return

// boxKeyGet(): void
boxKeyGet:
	proto 0 0

	// tests/contracts/storage.algo.ts:68
	// assert(this.boxKey.value === 'bar')
	bytec 0 //  "foo"
	box_get

	// box value does not exist: this.boxKey.value
	assert
	bytec 1 //  "bar"
	==
	assert
	retsub

// boxKeyDelete()void
*abi_route_boxKeyDelete:
	// execute boxKeyDelete()void
	callsub boxKeyDelete
	intc 0 // 1
	return

// boxKeyDelete(): void
boxKeyDelete:
	proto 0 0

	// tests/contracts/storage.algo.ts:72
	// this.boxKey.delete()
	bytec 0 //  "foo"
	box_del
	retsub

// boxKeyExists()void
*abi_route_boxKeyExists:
	// execute boxKeyExists()void
	callsub boxKeyExists
	intc 0 // 1
	return

// boxKeyExists(): void
boxKeyExists:
	proto 0 0

	// tests/contracts/storage.algo.ts:76
	// assert(this.boxKey.exists)
	bytec 0 //  "foo"
	box_len
	swap
	pop
	assert
	retsub

// globalMapPut()void
*abi_route_globalMapPut:
	// execute globalMapPut()void
	callsub globalMapPut
	intc 0 // 1
	return

// globalMapPut(): void
globalMapPut:
	proto 0 0

	// tests/contracts/storage.algo.ts:80
	// this.globalMap('foo').value = 'bar'
	bytec 0 //  "foo"
	bytec 1 //  "bar"
	app_global_put
	retsub

// globalMapGet()void
*abi_route_globalMapGet:
	// execute globalMapGet()void
	callsub globalMapGet
	intc 0 // 1
	return

// globalMapGet(): void
globalMapGet:
	proto 0 0

	// tests/contracts/storage.algo.ts:84
	// assert(this.globalMap('foo').value === 'bar')
	bytec 0 //  "foo"
	app_global_get
	bytec 1 //  "bar"
	==
	assert
	retsub

// globalMapDelete()void
*abi_route_globalMapDelete:
	// execute globalMapDelete()void
	callsub globalMapDelete
	intc 0 // 1
	return

// globalMapDelete(): void
globalMapDelete:
	proto 0 0

	// tests/contracts/storage.algo.ts:88
	// this.globalMap('foo').delete()
	bytec 0 //  "foo"
	app_global_del
	retsub

// globalMapExists()void
*abi_route_globalMapExists:
	// execute globalMapExists()void
	callsub globalMapExists
	intc 0 // 1
	return

// globalMapExists(): void
globalMapExists:
	proto 0 0

	// tests/contracts/storage.algo.ts:92
	// assert(this.globalMap('foo').exists)
	txna Applications 0
	bytec 0 //  "foo"
	app_global_get_ex
	swap
	pop
	assert
	retsub

// localMapPut(address)void
*abi_route_localMapPut:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for localMapPut must be a address
	assert

	// execute localMapPut(address)void
	callsub localMapPut
	intc 0 // 1
	return

// localMapPut(a: Address): void
localMapPut:
	proto 1 0

	// tests/contracts/storage.algo.ts:96
	// this.localMap(a, 'foo').value = 'bar'
	frame_dig -1 // a: Address
	bytec 0 //  "foo"
	bytec 1 //  "bar"
	app_local_put
	retsub

// localMapGet(address)void
*abi_route_localMapGet:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for localMapGet must be a address
	assert

	// execute localMapGet(address)void
	callsub localMapGet
	intc 0 // 1
	return

// localMapGet(a: Address): void
localMapGet:
	proto 1 0

	// tests/contracts/storage.algo.ts:100
	// assert(this.localMap(a, 'foo').value === 'bar')
	frame_dig -1 // a: Address
	bytec 0 //  "foo"
	app_local_get
	bytec 1 //  "bar"
	==
	assert
	retsub

// localMapDelete(address)void
*abi_route_localMapDelete:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for localMapDelete must be a address
	assert

	// execute localMapDelete(address)void
	callsub localMapDelete
	intc 0 // 1
	return

// localMapDelete(a: Address): void
localMapDelete:
	proto 1 0

	// tests/contracts/storage.algo.ts:104
	// this.localMap(a, 'foo').delete()
	frame_dig -1 // a: Address
	bytec 0 //  "foo"
	app_local_del
	retsub

// localMapExists(address)void
*abi_route_localMapExists:
	// a: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for localMapExists must be a address
	assert

	// execute localMapExists(address)void
	callsub localMapExists
	intc 0 // 1
	return

// localMapExists(a: Address): void
localMapExists:
	proto 1 0

	// tests/contracts/storage.algo.ts:108
	// assert(this.localMap(a, 'foo').exists)
	frame_dig -1 // a: Address
	txna Applications 0
	bytec 0 //  "foo"
	app_local_get_ex
	swap
	pop
	assert
	retsub

// boxMapPut()void
*abi_route_boxMapPut:
	// execute boxMapPut()void
	callsub boxMapPut
	intc 0 // 1
	return

// boxMapPut(): void
boxMapPut:
	proto 0 0

	// tests/contracts/storage.algo.ts:112
	// this.boxMap('foo').value = 'bar'
	bytec 0 //  "foo"
	bytec 1 //  "bar"
	box_put
	retsub

// boxMapGet()void
*abi_route_boxMapGet:
	// execute boxMapGet()void
	callsub boxMapGet
	intc 0 // 1
	return

// boxMapGet(): void
boxMapGet:
	proto 0 0

	// tests/contracts/storage.algo.ts:116
	// assert(this.boxMap('foo').value === 'bar')
	bytec 0 //  "foo"
	box_get

	// box value does not exist: this.boxMap('foo').value
	assert
	bytec 1 //  "bar"
	==
	assert
	retsub

// boxMapDelete()void
*abi_route_boxMapDelete:
	// execute boxMapDelete()void
	callsub boxMapDelete
	intc 0 // 1
	return

// boxMapDelete(): void
boxMapDelete:
	proto 0 0

	// tests/contracts/storage.algo.ts:120
	// this.boxMap('foo').delete()
	bytec 0 //  "foo"
	box_del
	retsub

// boxMapExists()void
*abi_route_boxMapExists:
	// execute boxMapExists()void
	callsub boxMapExists
	intc 0 // 1
	return

// boxMapExists(): void
boxMapExists:
	proto 0 0

	// tests/contracts/storage.algo.ts:124
	// assert(this.boxMap('foo').exists)
	bytec 0 //  "foo"
	box_len
	swap
	pop
	assert
	retsub

// boxKeyCreate()void
*abi_route_boxKeyCreate:
	// execute boxKeyCreate()void
	callsub boxKeyCreate
	intc 0 // 1
	return

// boxKeyCreate(): void
boxKeyCreate:
	proto 0 0

	// tests/contracts/storage.algo.ts:128
	// this.boxKey.create(1024)
	bytec 0 //  "foo"
	intc 3 // 1024
	box_create
	pop
	retsub

// boxMapCreate()void
*abi_route_boxMapCreate:
	// execute boxMapCreate()void
	callsub boxMapCreate
	intc 0 // 1
	return

// boxMapCreate(): void
boxMapCreate:
	proto 0 0

	// tests/contracts/storage.algo.ts:132
	// this.boxMap('bar').create(1024)
	bytec 1 //  "bar"
	intc 3 // 1024
	box_create
	pop
	retsub

// boxKeyLength()uint64
*abi_route_boxKeyLength:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// execute boxKeyLength()uint64
	callsub boxKeyLength
	itob
	concat
	log
	intc 0 // 1
	return

// boxKeyLength(): uint64
boxKeyLength:
	proto 0 1

	// tests/contracts/storage.algo.ts:136
	// return this.boxKey.size;
	bytec 0 //  "foo"
	box_len

	// box value does not exist: this.boxKey.size
	assert
	retsub

// boxMapLength()uint64
*abi_route_boxMapLength:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// execute boxMapLength()uint64
	callsub boxMapLength
	itob
	concat
	log
	intc 0 // 1
	return

// boxMapLength(): uint64
boxMapLength:
	proto 0 1

	// tests/contracts/storage.algo.ts:140
	// return this.boxMap('bar').size;
	bytec 1 //  "bar"
	box_len

	// box value does not exist: this.boxMap('bar').size
	assert
	retsub

// boxKeyReplace()void
*abi_route_boxKeyReplace:
	// execute boxKeyReplace()void
	callsub boxKeyReplace
	intc 0 // 1
	return

// boxKeyReplace(): void
boxKeyReplace:
	proto 0 0

	// tests/contracts/storage.algo.ts:144
	// this.boxKey.replace(0, 'abc')
	bytec 0 //  "foo"
	intc 2 // 0
	bytec 4 //  "abc"
	box_replace
	retsub

// boxMapReplace()void
*abi_route_boxMapReplace:
	// execute boxMapReplace()void
	callsub boxMapReplace
	intc 0 // 1
	return

// boxMapReplace(): void
boxMapReplace:
	proto 0 0

	// tests/contracts/storage.algo.ts:148
	// this.boxMap('bar').replace(0, 'abc')
	bytec 1 //  "bar"
	intc 2 // 0
	bytec 4 //  "abc"
	box_replace
	retsub

// boxKeyExtract()string
*abi_route_boxKeyExtract:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// execute boxKeyExtract()string
	callsub boxKeyExtract
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// boxKeyExtract(): string
boxKeyExtract:
	proto 0 1

	// tests/contracts/storage.algo.ts:152
	// return this.boxKey.extract(0, 3);
	bytec 0 //  "foo"
	intc 2 // 0
	intc 6 // 3
	box_extract
	retsub

// boxMapExtract()string
*abi_route_boxMapExtract:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// execute boxMapExtract()string
	callsub boxMapExtract
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// boxMapExtract(): string
boxMapExtract:
	proto 0 1

	// tests/contracts/storage.algo.ts:156
	// return this.boxMap('bar').extract(0, 3);
	bytec 1 //  "bar"
	intc 2 // 0
	intc 6 // 3
	box_extract
	retsub

// isOptedIn()bool
*abi_route_isOptedIn:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// execute isOptedIn()bool
	callsub isOptedIn
	pushbytes 0x00
	intc 2 // 0
	uncover 2
	setbit
	concat
	log
	intc 0 // 1
	return

// isOptedIn(): boolean
isOptedIn:
	proto 0 1

	// tests/contracts/storage.algo.ts:160
	// return this.txn.sender.isOptedInToApp(this.app);
	txn Sender
	txna Applications 0
	app_opted_in
	retsub

// exGlobal()void
*abi_route_exGlobal:
	// execute exGlobal()void
	callsub exGlobal
	intc 0 // 1
	return

// exGlobal(): void
exGlobal:
	proto 0 0

	// tests/contracts/storage.algo.ts:164
	// log(this.app.globalState('foo') as bytes)
	txna Applications 0
	bytec 0 //  "foo"
	app_global_get_ex

	// global state value does not exist: this.app.globalState('foo')
	assert
	log
	retsub

// exLocal()void
*abi_route_exLocal:
	// execute exLocal()void
	callsub exLocal
	intc 0 // 1
	return

// exLocal(): void
exLocal:
	proto 0 0

	// tests/contracts/storage.algo.ts:168
	// log(this.app.localState(this.txn.sender, 'foo') as bytes)
	txn Sender
	txna Applications 0
	bytec 0 //  "foo"
	app_local_get_ex

	// local state value does not exist: this.app.localState(this.txn.sender, 'foo')
	assert
	log
	retsub

// accessStaticValueInLargeBox()uint16
*abi_route_accessStaticValueInLargeBox:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// execute accessStaticValueInLargeBox()uint16
	callsub accessStaticValueInLargeBox
	itob
	dup
	bitlen
	intc 7 // 16
	<=

	// accessStaticValueInLargeBox return value overflowed 16 bits
	assert
	extract 6 2
	concat
	log
	intc 0 // 1
	return

// accessStaticValueInLargeBox(): uint16
accessStaticValueInLargeBox:
	proto 0 1

	// tests/contracts/storage.algo.ts:172
	// this.largeStaticArrayInBox.create()
	bytec 3 //  "largeStaticArrayInBox"
	intc 5 // 8000
	box_create
	pop

	// tests/contracts/storage.algo.ts:173
	// this.largeStaticArrayInBox.value[123] = 456
	bytec 3 //  "largeStaticArrayInBox"
	intc 8 // 246
	bytec 5 // 0x01c8
	box_replace

	// tests/contracts/storage.algo.ts:175
	// return this.largeStaticArrayInBox.value[123];
	bytec 3 //  "largeStaticArrayInBox"
	intc 8 // 246
	intc 4 // 2
	box_extract
	btoi
	retsub

// dynamicAccessStaticValueInLargeBox(uint64)uint16
*abi_route_dynamicAccessStaticValueInLargeBox:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// i: uint64
	txna ApplicationArgs 1
	btoi

	// execute dynamicAccessStaticValueInLargeBox(uint64)uint16
	callsub dynamicAccessStaticValueInLargeBox
	itob
	dup
	bitlen
	intc 7 // 16
	<=

	// dynamicAccessStaticValueInLargeBox return value overflowed 16 bits
	assert
	extract 6 2
	concat
	log
	intc 0 // 1
	return

// dynamicAccessStaticValueInLargeBox(i: uint64): uint16
dynamicAccessStaticValueInLargeBox:
	proto 1 1

	// tests/contracts/storage.algo.ts:179
	// this.largeStaticArrayInBox.create()
	bytec 3 //  "largeStaticArrayInBox"
	intc 5 // 8000
	box_create
	pop

	// tests/contracts/storage.algo.ts:180
	// this.largeStaticArrayInBox.value[i] = 456
	frame_dig -1 // i: uint64
	intc 4 // 2
	* // acc * typeLength
	bytec 5 // 0x01c8
	bytec 3 //  "largeStaticArrayInBox"
	cover 2
	box_replace

	// tests/contracts/storage.algo.ts:184
	// return a[i];
	frame_dig -1 // i: uint64
	intc 4 // 2
	* // acc * typeLength
	intc 4 // 2
	bytec 3 //  "largeStaticArrayInBox"
	cover 2
	box_extract
	btoi
	retsub

// boxResize()void
*abi_route_boxResize:
	// execute boxResize()void
	callsub boxResize
	intc 0 // 1
	return

// boxResize(): void
boxResize:
	proto 0 0

	// tests/contracts/storage.algo.ts:188
	// this.boxKey.resize(1024)
	bytec 0 //  "foo"
	intc 3 // 1024
	box_resize

	// tests/contracts/storage.algo.ts:189
	// this.boxMap('bar').resize(1024)
	bytec 1 //  "bar"
	intc 3 // 1024
	box_resize
	retsub

// boxSplice()void
*abi_route_boxSplice:
	// execute boxSplice()void
	callsub boxSplice
	intc 0 // 1
	return

// boxSplice(): void
boxSplice:
	proto 0 0

	// tests/contracts/storage.algo.ts:193
	// this.boxKey.splice(0, 1, 'abc')
	bytec 0 //  "foo"
	intc 2 // 0
	intc 0 // 1
	bytec 4 //  "abc"
	box_splice

	// tests/contracts/storage.algo.ts:194
	// this.boxMap('bar').splice(0, 1, 'abc')
	bytec 1 //  "bar"
	intc 2 // 0
	intc 0 // 1
	bytec 4 //  "abc"
	box_splice
	retsub

// exStateExists()void
*abi_route_exStateExists:
	// execute exStateExists()void
	callsub exStateExists
	intc 0 // 1
	return

// exStateExists(): void
exStateExists:
	proto 0 0

	// tests/contracts/storage.algo.ts:198
	// assert(this.app.globalStateExists('foo'))
	txna Applications 0
	bytec 0 //  "foo"
	app_global_get_ex
	swap
	pop
	assert

	// tests/contracts/storage.algo.ts:199
	// assert(this.app.localStateExists(this.txn.sender, 'foo'))
	txn Sender
	txna Applications 0
	bytec 0 //  "foo"
	app_local_get_ex
	swap
	pop
	assert
	retsub

*abi_route_createApplication:
	intc 0 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x5b02ba87 // method "prefix()void"
	pushbytes 0x47826307 // method "globalKeyPut()void"
	pushbytes 0xd387cd2c // method "globalKeyGet()void"
	pushbytes 0x2f78db03 // method "globalKeyDelete()void"
	pushbytes 0xd8181a9a // method "globalKeyExists()void"
	pushbytes 0xecb06998 // method "localKeyPut(address)void"
	pushbytes 0x56dace1d // method "localKeyGet(address)void"
	pushbytes 0x768c8c68 // method "localKeyDelete(address)void"
	pushbytes 0xbc0ea6bb // method "localKeyExists(address)void"
	pushbytes 0xcf48ae4d // method "boxKeyPut()void"
	pushbytes 0xe9dab493 // method "boxKeyGet()void"
	pushbytes 0x090fdfd6 // method "boxKeyDelete()void"
	pushbytes 0x5ff9d0dd // method "boxKeyExists()void"
	pushbytes 0x17c8206a // method "globalMapPut()void"
	pushbytes 0xcd868bf2 // method "globalMapGet()void"
	pushbytes 0xb55de20c // method "globalMapDelete()void"
	pushbytes 0xc97d8d24 // method "globalMapExists()void"
	pushbytes 0xfc83803c // method "localMapPut(address)void"
	pushbytes 0x9875355d // method "localMapGet(address)void"
	pushbytes 0x742a6e83 // method "localMapDelete(address)void"
	pushbytes 0x88235265 // method "localMapExists(address)void"
	pushbytes 0x84e5681c // method "boxMapPut()void"
	pushbytes 0xae3ce7ee // method "boxMapGet()void"
	pushbytes 0xb9e0ed3d // method "boxMapDelete()void"
	pushbytes 0x652bd5d6 // method "boxMapExists()void"
	pushbytes 0xd36ee315 // method "boxKeyCreate()void"
	pushbytes 0x1029bd07 // method "boxMapCreate()void"
	pushbytes 0xa747b62f // method "boxKeyLength()uint64"
	pushbytes 0x5a1eefbe // method "boxMapLength()uint64"
	pushbytes 0x1337dd60 // method "boxKeyReplace()void"
	pushbytes 0x424ef95a // method "boxMapReplace()void"
	pushbytes 0x88c1c309 // method "boxKeyExtract()string"
	pushbytes 0x43635643 // method "boxMapExtract()string"
	pushbytes 0xab42554e // method "isOptedIn()bool"
	pushbytes 0x0167b7a2 // method "exGlobal()void"
	pushbytes 0xaad51755 // method "exLocal()void"
	pushbytes 0x1b41ce22 // method "accessStaticValueInLargeBox()uint16"
	pushbytes 0xf5da1a55 // method "dynamicAccessStaticValueInLargeBox(uint64)uint16"
	pushbytes 0xbc5c18fd // method "boxResize()void"
	pushbytes 0x25a92329 // method "boxSplice()void"
	pushbytes 0x4ed8699b // method "exStateExists()void"
	txna ApplicationArgs 0
	match *abi_route_prefix *abi_route_globalKeyPut *abi_route_globalKeyGet *abi_route_globalKeyDelete *abi_route_globalKeyExists *abi_route_localKeyPut *abi_route_localKeyGet *abi_route_localKeyDelete *abi_route_localKeyExists *abi_route_boxKeyPut *abi_route_boxKeyGet *abi_route_boxKeyDelete *abi_route_boxKeyExists *abi_route_globalMapPut *abi_route_globalMapGet *abi_route_globalMapDelete *abi_route_globalMapExists *abi_route_localMapPut *abi_route_localMapGet *abi_route_localMapDelete *abi_route_localMapExists *abi_route_boxMapPut *abi_route_boxMapGet *abi_route_boxMapDelete *abi_route_boxMapExists *abi_route_boxKeyCreate *abi_route_boxMapCreate *abi_route_boxKeyLength *abi_route_boxMapLength *abi_route_boxKeyReplace *abi_route_boxMapReplace *abi_route_boxKeyExtract *abi_route_boxMapExtract *abi_route_isOptedIn *abi_route_exGlobal *abi_route_exLocal *abi_route_accessStaticValueInLargeBox *abi_route_dynamicAccessStaticValueInLargeBox *abi_route_boxResize *abi_route_boxSplice *abi_route_exStateExists

	// this contract does not implement the given ABI method for call NoOp
	err