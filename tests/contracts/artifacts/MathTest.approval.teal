#pragma version 10
intcblock 1 32 256 16 8 0 128 18446744073709551615 2 3 4 5 64
bytecblock 0x151f7c75 0x 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 0x626f784b6579 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 0x674b6579 0x0000000000000000000000000000000000000000000000000000000000000001 0x00000000000000000000000000000000000000000000000000000000000003e8 0x7265776172645065725368617265 0xFFFFFFFFFFFFFFFF

// This TEAL was generated by TEALScript v0.107.2
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// u64plus(uint64,uint64)uint64
*abi_route_u64plus:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64plus(uint64,uint64)uint64
	callsub u64plus
	itob
	concat
	log
	intc 0 // 1
	return

// u64plus(a: uint64, b: uint64): uint64
u64plus:
	proto 2 1

	// tests/contracts/math.algo.ts:14
	// return a + b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	+
	retsub

// u64minus(uint64,uint64)uint64
*abi_route_u64minus:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64minus(uint64,uint64)uint64
	callsub u64minus
	itob
	concat
	log
	intc 0 // 1
	return

// u64minus(a: uint64, b: uint64): uint64
u64minus:
	proto 2 1

	// tests/contracts/math.algo.ts:18
	// return a - b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	-
	retsub

// u64mul(uint64,uint64)uint64
*abi_route_u64mul:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64mul(uint64,uint64)uint64
	callsub u64mul
	itob
	concat
	log
	intc 0 // 1
	return

// u64mul(a: uint64, b: uint64): uint64
u64mul:
	proto 2 1

	// tests/contracts/math.algo.ts:22
	// return a * b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	*
	retsub

// u64div(uint64,uint64)uint64
*abi_route_u64div:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64div(uint64,uint64)uint64
	callsub u64div
	itob
	concat
	log
	intc 0 // 1
	return

// u64div(a: uint64, b: uint64): uint64
u64div:
	proto 2 1

	// tests/contracts/math.algo.ts:26
	// return a / b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	/
	retsub

// u256plus(uint256,uint256)uint256
*abi_route_u256plus:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 32
	==

	// argument 0 (b) for u256plus must be a uint256
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 1 (a) for u256plus must be a uint256
	assert

	// execute u256plus(uint256,uint256)uint256
	callsub u256plus
	dup
	bitlen
	intc 2 // 256
	<=

	// u256plus return value overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 1 // 32
	-
	swap
	substring3
	concat
	log
	intc 0 // 1
	return

// u256plus(a: uint256, b: uint256): uint256
u256plus:
	proto 2 1

	// tests/contracts/math.algo.ts:30
	// return <uint256>(a + b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b+
	retsub

// u256minus(uint256,uint256)uint256
*abi_route_u256minus:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 32
	==

	// argument 0 (b) for u256minus must be a uint256
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 1 (a) for u256minus must be a uint256
	assert

	// execute u256minus(uint256,uint256)uint256
	callsub u256minus
	dup
	bitlen
	intc 2 // 256
	<=

	// u256minus return value overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 1 // 32
	-
	swap
	substring3
	concat
	log
	intc 0 // 1
	return

// u256minus(a: uint256, b: uint256): uint256
u256minus:
	proto 2 1

	// tests/contracts/math.algo.ts:34
	// return <uint256>(a - b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b-
	retsub

// u256mul(uint256,uint256)uint256
*abi_route_u256mul:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 32
	==

	// argument 0 (b) for u256mul must be a uint256
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 1 (a) for u256mul must be a uint256
	assert

	// execute u256mul(uint256,uint256)uint256
	callsub u256mul
	dup
	bitlen
	intc 2 // 256
	<=

	// u256mul return value overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 1 // 32
	-
	swap
	substring3
	concat
	log
	intc 0 // 1
	return

// u256mul(a: uint256, b: uint256): uint256
u256mul:
	proto 2 1

	// tests/contracts/math.algo.ts:38
	// return <uint256>(a * b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b*
	retsub

// u256div(uint256,uint256)uint256
*abi_route_u256div:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 32
	==

	// argument 0 (b) for u256div must be a uint256
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 1 (a) for u256div must be a uint256
	assert

	// execute u256div(uint256,uint256)uint256
	callsub u256div
	dup
	bitlen
	intc 2 // 256
	<=

	// u256div return value overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 1 // 32
	-
	swap
	substring3
	concat
	log
	intc 0 // 1
	return

// u256div(a: uint256, b: uint256): uint256
u256div:
	proto 2 1

	// tests/contracts/math.algo.ts:42
	// return <uint256>(a / b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b/
	retsub

// u64Return256(uint64,uint64)uint256
*abi_route_u64Return256:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute u64Return256(uint64,uint64)uint256
	callsub u64Return256
	dup
	bitlen
	intc 2 // 256
	<=

	// u64Return256 return value overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 1 // 32
	-
	swap
	substring3
	concat
	log
	intc 0 // 1
	return

// u64Return256(a: uint64, b: uint64): uint256
u64Return256:
	proto 2 1

	// tests/contracts/math.algo.ts:46
	// return <uint256>(a + b);
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	+
	itob
	retsub

// maxU64()uint64
*abi_route_maxU64:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// execute maxU64()uint64
	callsub maxU64
	itob
	concat
	log
	intc 0 // 1
	return

// maxU64(): uint64
maxU64:
	proto 0 1

	// tests/contracts/math.algo.ts:50
	// return Uint<64>('18446744073709551615');
	intc 7 // 18446744073709551615
	retsub

// exponent(uint64,uint64)uint64
*abi_route_exponent:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute exponent(uint64,uint64)uint64
	callsub exponent
	itob
	concat
	log
	intc 0 // 1
	return

// exponent(a: uint64, b: uint64): uint64
exponent:
	proto 2 1

	// tests/contracts/math.algo.ts:54
	// return a ** b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	exp
	retsub

// variableTypeHint(uint8,uint8)uint16
*abi_route_variableTypeHint:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// y: uint8
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 1
	==

	// argument 0 (y) for variableTypeHint must be a uint8
	assert
	btoi

	// x: uint8
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 1
	==

	// argument 1 (x) for variableTypeHint must be a uint8
	assert
	btoi

	// execute variableTypeHint(uint8,uint8)uint16
	callsub variableTypeHint
	itob
	dup
	bitlen
	intc 3 // 16
	<=

	// variableTypeHint return value overflowed 16 bits
	assert
	extract 6 2
	concat
	log
	intc 0 // 1
	return

// variableTypeHint(x: uint<8>, y: uint<8>): uint16
variableTypeHint:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// tests/contracts/math.algo.ts:58
	// z = <uint16>(x + y)
	frame_dig -1 // x: uint<8>
	frame_dig -2 // y: uint<8>
	+
	frame_bury 0 // z: unsafe uint16

	// tests/contracts/math.algo.ts:60
	// return z;
	frame_dig 0 // z: unsafe uint16

	// set the subroutine return value
	frame_bury 0
	retsub

// uint8plus(uint8,uint8)uint8
*abi_route_uint8plus:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint8
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 1
	==

	// argument 0 (b) for uint8plus must be a uint8
	assert
	btoi

	// a: uint8
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 1
	==

	// argument 1 (a) for uint8plus must be a uint8
	assert
	btoi

	// execute uint8plus(uint8,uint8)uint8
	callsub uint8plus
	itob
	dup
	bitlen
	intc 4 // 8
	<=

	// uint8plus return value overflowed 8 bits
	assert
	extract 7 1
	concat
	log
	intc 0 // 1
	return

// uint8plus(a: uint<8>, b: uint<8>): uint<8>
uint8plus:
	proto 2 1

	// tests/contracts/math.algo.ts:64
	// return a + b;
	frame_dig -1 // a: uint<8>
	frame_dig -2 // b: uint<8>
	+
	retsub

// uint8exp(uint8,uint8)uint8
*abi_route_uint8exp:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint8
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 1
	==

	// argument 0 (b) for uint8exp must be a uint8
	assert
	btoi

	// a: uint8
	txna ApplicationArgs 1
	dup
	len
	intc 0 // 1
	==

	// argument 1 (a) for uint8exp must be a uint8
	assert
	btoi

	// execute uint8exp(uint8,uint8)uint8
	callsub uint8exp
	itob
	dup
	bitlen
	intc 4 // 8
	<=

	// uint8exp return value overflowed 8 bits
	assert
	extract 7 1
	concat
	log
	intc 0 // 1
	return

// uint8exp(a: uint<8>, b: uint<8>): uint<8>
uint8exp:
	proto 2 1

	// tests/contracts/math.algo.ts:68
	// return a ** b;
	frame_dig -1 // a: uint<8>
	frame_dig -2 // b: uint<8>
	exp
	retsub

// plusEquals(uint64,uint64)uint64
*abi_route_plusEquals:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute plusEquals(uint64,uint64)uint64
	callsub plusEquals
	itob
	concat
	log
	intc 0 // 1
	return

// plusEquals(a: uint64, b: uint64): uint64
plusEquals:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// tests/contracts/math.algo.ts:72
	// x = a
	frame_dig -1 // a: uint64
	frame_bury 0 // x: uint64

	// tests/contracts/math.algo.ts:74
	// x += b
	frame_dig 0 // x: uint64
	frame_dig -2 // b: uint64
	+
	frame_bury 0 // x: uint64

	// tests/contracts/math.algo.ts:76
	// return x;
	frame_dig 0 // x: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// plusEqualsFromGlobal(uint64,uint64)uint64
*abi_route_plusEqualsFromGlobal:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute plusEqualsFromGlobal(uint64,uint64)uint64
	callsub plusEqualsFromGlobal
	itob
	concat
	log
	intc 0 // 1
	return

// plusEqualsFromGlobal(a: uint64, b: uint64): uint64
plusEqualsFromGlobal:
	proto 2 1

	// tests/contracts/math.algo.ts:80
	// this.gKey.value = a
	bytec 5 //  "gKey"
	frame_dig -1 // a: uint64
	app_global_put

	// tests/contracts/math.algo.ts:82
	// this.gKey.value += b
	bytec 5 //  "gKey"
	app_global_get
	frame_dig -2 // b: uint64
	+
	bytec 5 //  "gKey"
	swap
	app_global_put

	// tests/contracts/math.algo.ts:84
	// return this.gKey.value;
	bytec 5 //  "gKey"
	app_global_get
	retsub

// boxTest()uint256
*abi_route_boxTest:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// execute boxTest()uint256
	callsub boxTest
	dup
	bitlen
	intc 2 // 256
	<=

	// boxTest return value overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 1 // 32
	-
	swap
	substring3
	concat
	log
	intc 0 // 1
	return

// boxTest(): uint256
boxTest:
	proto 0 1

	// tests/contracts/math.algo.ts:90
	// this.boxKey.value = <uint256>1
	bytec 3 //  "boxKey"
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000001
	box_put

	// tests/contracts/math.algo.ts:91
	// this.boxKey.value += 1
	bytec 3 //  "boxKey"
	box_get

	// box value does not exist: this.boxKey.value
	assert
	bytec 6 // 0x0000000000000000000000000000000000000000000000000000000000000001
	b+
	bytec 3 //  "boxKey"
	dup
	bitlen
	intc 2 // 256
	<=

	// this.boxKey.value overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 1 // 32
	-
	swap
	substring3
	swap
	box_put

	// tests/contracts/math.algo.ts:93
	// return this.boxKey.value;
	bytec 3 //  "boxKey"
	box_get

	// box value does not exist: this.boxKey.value
	assert
	retsub

// foo(x: uint256): uint256
foo:
	proto 1 1

	// tests/contracts/math.algo.ts:97
	// return x;
	frame_dig -1 // x: uint256
	retsub

// unsafeMethodArgs(uint256,uint256)uint256
*abi_route_unsafeMethodArgs:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 32
	==

	// argument 0 (b) for unsafeMethodArgs must be a uint256
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 1 (a) for unsafeMethodArgs must be a uint256
	assert

	// execute unsafeMethodArgs(uint256,uint256)uint256
	callsub unsafeMethodArgs
	dup
	bitlen
	intc 2 // 256
	<=

	// unsafeMethodArgs return value overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 1 // 32
	-
	swap
	substring3
	concat
	log
	intc 0 // 1
	return

// unsafeMethodArgs(a: uint256, b: uint256): uint256
unsafeMethodArgs:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// tests/contracts/math.algo.ts:101
	// c = a + b
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b+
	frame_bury 0 // c: unsafe uint256

	// tests/contracts/math.algo.ts:103
	// return this.foo(c);
	frame_dig 0 // c: unsafe uint256
	dup
	bitlen
	intc 2 // 256
	<=

	// c overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 1 // 32
	-
	swap
	substring3
	callsub foo

	// set the subroutine return value
	frame_bury 0
	retsub

// uint256ComparisonType(uint256,uint256)void
*abi_route_uint256ComparisonType:
	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 32
	==

	// argument 0 (b) for uint256ComparisonType must be a uint256
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 1 (a) for uint256ComparisonType must be a uint256
	assert

	// execute uint256ComparisonType(uint256,uint256)void
	callsub uint256ComparisonType
	intc 0 // 1
	return

// uint256ComparisonType(a: uint256, b: uint256): void
uint256ComparisonType:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// tests/contracts/math.algo.ts:107
	// senderBalanceAfter = a - b
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b-
	frame_bury 0 // senderBalanceAfter: unsafe uint256

	// *if0_condition
	// tests/contracts/math.algo.ts:108
	// senderBalanceAfter > <uint256>0
	frame_dig 0 // senderBalanceAfter: unsafe uint256
	pushbytes 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	bz *if0_else

	// *if0_consequent
	// tests/contracts/math.algo.ts:109
	// log('nonZero')
	pushbytes 0x6e6f6e5a65726f // "nonZero"
	log
	b *if0_end

*if0_else:
	// tests/contracts/math.algo.ts:111
	// log('zero')
	pushbytes 0x7a65726f // "zero"
	log

*if0_end:
	retsub

// squareRoot256(uint256,uint256)uint256
*abi_route_squareRoot256:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 32
	==

	// argument 0 (b) for squareRoot256 must be a uint256
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 1 (a) for squareRoot256 must be a uint256
	assert

	// execute squareRoot256(uint256,uint256)uint256
	callsub squareRoot256
	dup
	bitlen
	intc 2 // 256
	<=

	// squareRoot256 return value overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 1 // 32
	-
	swap
	substring3
	concat
	log
	intc 0 // 1
	return

// squareRoot256(a: uint256, b: uint256): uint256
squareRoot256:
	proto 2 1

	// tests/contracts/math.algo.ts:116
	// return sqrt(a * b);
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b*
	bsqrt
	retsub

// squareRoot64(uint64,uint64)uint64
*abi_route_squareRoot64:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute squareRoot64(uint64,uint64)uint64
	callsub squareRoot64
	itob
	concat
	log
	intc 0 // 1
	return

// squareRoot64(a: uint64, b: uint64): uint64
squareRoot64:
	proto 2 1

	// tests/contracts/math.algo.ts:120
	// return sqrt(a * b);
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	*
	sqrt
	retsub

// addressToBigInt(address)bool
*abi_route_addressToBigInt:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// addr: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (addr) for addressToBigInt must be a address
	assert

	// execute addressToBigInt(address)bool
	callsub addressToBigInt
	pushbytes 0x00
	intc 5 // 0
	uncover 2
	setbit
	concat
	log
	intc 0 // 1
	return

// addressToBigInt(addr: Address): boolean
addressToBigInt:
	proto 1 1

	// tests/contracts/math.algo.ts:124
	// return btobigint(addr) > btobigint(this.txn.sender);
	frame_dig -1 // addr: Address
	txn Sender
	b>
	retsub

// u8Tou64()uint64
*abi_route_u8Tou64:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// execute u8Tou64()uint64
	callsub u8Tou64
	itob
	concat
	log
	intc 0 // 1
	return

// u8Tou64(): uint64
u8Tou64:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// tests/contracts/math.algo.ts:128
	// x: uint8 = 7
	pushint 7
	frame_bury 0 // x: uint8

	// tests/contracts/math.algo.ts:129
	// return <uint64>x;
	frame_dig 0 // x: uint8

	// set the subroutine return value
	frame_bury 0
	retsub

// privateFuncName(x: uint8, y: uint64): void
privateFuncName:
	proto 2 0

	// tests/contracts/math.algo.ts:133
	// assert(<uint8>y > x)
	frame_dig -2 // y: uint64
	frame_dig -1 // x: uint8
	>
	assert
	retsub

// funcName(uint256)void
*abi_route_funcName:
	// x: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (x) for funcName must be a uint256
	assert

	// execute funcName(uint256)void
	callsub funcName
	intc 0 // 1
	return

// funcName(x: uint256): void
funcName:
	proto 1 0

	// tests/contracts/math.algo.ts:137
	// this.privateFuncName(<uint8>x, 1337)
	pushint 1337
	frame_dig -1 // x: uint256
	dup
	bitlen
	intc 4 // 8
	<=

	// <uint8>x overflowed 8 bits
	assert
	extract 31 1
	btoi
	callsub privateFuncName
	retsub

// bigintPlus(uint64,uint64)uint64
*abi_route_bigintPlus:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bigintPlus(uint64,uint64)uint64
	callsub bigintPlus
	itob
	concat
	log
	intc 0 // 1
	return

// bigintPlus(a: uint64, b: uint64): uint64
bigintPlus:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// tests/contracts/math.algo.ts:141
	// x = itob(a)
	frame_dig -1 // a: uint64
	itob
	frame_bury 0 // x: byte[]

	// tests/contracts/math.algo.ts:142
	// y = itob(b)
	frame_dig -2 // b: uint64
	itob
	frame_bury 1 // y: byte[]

	// tests/contracts/math.algo.ts:143
	// return (btobigint(x) + btobigint(y)) as uint64;
	frame_dig 0 // x: byte[]
	frame_dig 1 // y: byte[]
	b+
	dup
	bitlen
	intc 12 // 64
	<=

	// (btobigint(x) + btobigint(y)) as uint64 overflowed 64 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 4 // 8
	-
	swap
	substring3
	btoi

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// bitwiseOr(uint64,uint64)uint64
*abi_route_bitwiseOr:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bitwiseOr(uint64,uint64)uint64
	callsub bitwiseOr
	itob
	concat
	log
	intc 0 // 1
	return

// bitwiseOr(a: uint64, b: uint64): uint64
bitwiseOr:
	proto 2 1

	// tests/contracts/math.algo.ts:147
	// return a | b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	|
	retsub

// bitwiseAnd(uint64,uint64)uint64
*abi_route_bitwiseAnd:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bitwiseAnd(uint64,uint64)uint64
	callsub bitwiseAnd
	itob
	concat
	log
	intc 0 // 1
	return

// bitwiseAnd(a: uint64, b: uint64): uint64
bitwiseAnd:
	proto 2 1

	// tests/contracts/math.algo.ts:151
	// return a & b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	&
	retsub

// bitwiseXor(uint64,uint64)uint64
*abi_route_bitwiseXor:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bitwiseXor(uint64,uint64)uint64
	callsub bitwiseXor
	itob
	concat
	log
	intc 0 // 1
	return

// bitwiseXor(a: uint64, b: uint64): uint64
bitwiseXor:
	proto 2 1

	// tests/contracts/math.algo.ts:155
	// return a ^ b;
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	^
	retsub

// bitwiseOrU256(uint256,uint256)uint256
*abi_route_bitwiseOrU256:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 32
	==

	// argument 0 (b) for bitwiseOrU256 must be a uint256
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 1 (a) for bitwiseOrU256 must be a uint256
	assert

	// execute bitwiseOrU256(uint256,uint256)uint256
	callsub bitwiseOrU256
	dup
	bitlen
	intc 2 // 256
	<=

	// bitwiseOrU256 return value overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 1 // 32
	-
	swap
	substring3
	concat
	log
	intc 0 // 1
	return

// bitwiseOrU256(a: uint256, b: uint256): uint256
bitwiseOrU256:
	proto 2 1

	// tests/contracts/math.algo.ts:159
	// return a | b;
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b|
	retsub

// bitwiseAndU256(uint256,uint256)uint256
*abi_route_bitwiseAndU256:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 32
	==

	// argument 0 (b) for bitwiseAndU256 must be a uint256
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 1 (a) for bitwiseAndU256 must be a uint256
	assert

	// execute bitwiseAndU256(uint256,uint256)uint256
	callsub bitwiseAndU256
	dup
	bitlen
	intc 2 // 256
	<=

	// bitwiseAndU256 return value overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 1 // 32
	-
	swap
	substring3
	concat
	log
	intc 0 // 1
	return

// bitwiseAndU256(a: uint256, b: uint256): uint256
bitwiseAndU256:
	proto 2 1

	// tests/contracts/math.algo.ts:163
	// return a & b;
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b&
	retsub

// bitwiseXorU256(uint256,uint256)uint256
*abi_route_bitwiseXorU256:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint256
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 32
	==

	// argument 0 (b) for bitwiseXorU256 must be a uint256
	assert

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 1 (a) for bitwiseXorU256 must be a uint256
	assert

	// execute bitwiseXorU256(uint256,uint256)uint256
	callsub bitwiseXorU256
	dup
	bitlen
	intc 2 // 256
	<=

	// bitwiseXorU256 return value overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 1 // 32
	-
	swap
	substring3
	concat
	log
	intc 0 // 1
	return

// bitwiseXorU256(a: uint256, b: uint256): uint256
bitwiseXorU256:
	proto 2 1

	// tests/contracts/math.algo.ts:167
	// return a ^ b;
	frame_dig -1 // a: uint256
	frame_dig -2 // b: uint256
	b^
	retsub

// bitwiseNot(uint64)uint64
*abi_route_bitwiseNot:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute bitwiseNot(uint64)uint64
	callsub bitwiseNot
	itob
	concat
	log
	intc 0 // 1
	return

// bitwiseNot(a: uint64): uint64
bitwiseNot:
	proto 1 1

	// tests/contracts/math.algo.ts:171
	// return ~a;
	frame_dig -1 // a: uint64
	~
	retsub

// bitwiseNotU256(uint256)uint256
*abi_route_bitwiseNotU256:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// a: uint256
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 0 (a) for bitwiseNotU256 must be a uint256
	assert

	// execute bitwiseNotU256(uint256)uint256
	callsub bitwiseNotU256
	dup
	bitlen
	intc 2 // 256
	<=

	// bitwiseNotU256 return value overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 1 // 32
	-
	swap
	substring3
	concat
	log
	intc 0 // 1
	return

// bitwiseNotU256(a: uint256): uint256
bitwiseNotU256:
	proto 1 1

	// tests/contracts/math.algo.ts:175
	// return ~a;
	frame_dig -1 // a: uint256
	b~
	retsub

// mulw(uint64,uint64)uint64
*abi_route_mulw:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute mulw(uint64,uint64)uint64
	callsub mulw
	itob
	concat
	log
	intc 0 // 1
	return

// mulw(a: uint64, b: uint64): uint64
mulw:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// tests/contracts/math.algo.ts:179
	// p = mulw(a, b)
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	mulw
	frame_bury 0 // p low: uint64
	frame_bury 1 // p high: uint64

	// tests/contracts/math.algo.ts:183
	// return p2.low;
	frame_dig 0 // p low: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// addw(uint64,uint64)uint64
*abi_route_addw:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute addw(uint64,uint64)uint64
	callsub addw
	itob
	concat
	log
	intc 0 // 1
	return

// addw(a: uint64, b: uint64): uint64
addw:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// tests/contracts/math.algo.ts:187
	// p = addw(a, b)
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	addw
	frame_bury 0 // p low: uint64
	frame_bury 1 // p high: uint64

	// tests/contracts/math.algo.ts:191
	// return p2.low;
	frame_dig 0 // p low: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// expw(uint64,uint64)uint64
*abi_route_expw:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute expw(uint64,uint64)uint64
	callsub expw
	itob
	concat
	log
	intc 0 // 1
	return

// expw(a: uint64, b: uint64): uint64
expw:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// tests/contracts/math.algo.ts:195
	// p = expw(a, b)
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	expw
	frame_bury 0 // p low: uint64
	frame_bury 1 // p high: uint64

	// tests/contracts/math.algo.ts:199
	// return p2.low;
	frame_dig 0 // p low: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// divw(uint64,uint64)uint64
*abi_route_divw:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute divw(uint64,uint64)uint64
	callsub divw
	itob
	concat
	log
	intc 0 // 1
	return

// divw(a: uint64, b: uint64): uint64
divw:
	proto 2 1

	// tests/contracts/math.algo.ts:203
	// return divw(0, a, b);
	intc 5 // 0
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	divw
	retsub

// divmodw(uint64,uint64)uint64
*abi_route_divmodw:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// b: uint64
	txna ApplicationArgs 2
	btoi

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute divmodw(uint64,uint64)uint64
	callsub divmodw
	itob
	concat
	log
	intc 0 // 1
	return

// divmodw(a: uint64, b: uint64): uint64
divmodw:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 3

	// tests/contracts/math.algo.ts:207
	// p = divmodw(0, a, 0, b)
	intc 5 // 0
	frame_dig -1 // a: uint64
	intc 5 // 0
	frame_dig -2 // b: uint64
	divmodw
	frame_bury 0 // p remainderLow: uint64
	frame_bury 1 // p remainderHigh: uint64
	frame_bury 2 // p quotientLow: uint64
	frame_bury 3 // p quotientHigh: uint64

	// tests/contracts/math.algo.ts:211
	// return p2.quotientLow;
	frame_dig 2 // p quotientLow: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// unsafeVariables()uint64
*abi_route_unsafeVariables:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// execute unsafeVariables()uint64
	callsub unsafeVariables
	itob
	concat
	log
	intc 0 // 1
	return

// unsafeVariables(): uint64
unsafeVariables:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// tests/contracts/math.algo.ts:215
	// A = <uint256>250000000
	pushbytes 0x000000000000000000000000000000000000000000000000000000000ee6b280
	frame_bury 0 // A: unsafe uint256

	// tests/contracts/math.algo.ts:216
	// B = <uint256>1000
	bytec 7 // 0x00000000000000000000000000000000000000000000000000000000000003e8
	frame_bury 1 // B: uint256

	// tests/contracts/math.algo.ts:218
	// A = A / B
	frame_dig 0 // A: unsafe uint256
	bytec 7 //  B: uint256
	b/
	frame_bury 0 // A: unsafe uint256

	// tests/contracts/math.algo.ts:220
	// c = A as uint64
	frame_dig 0 // A: unsafe uint256
	dup
	bitlen
	intc 12 // 64
	<=

	// A as uint64 overflowed 64 bits
	assert
	bytec 9 // 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 4 // 8
	-
	swap
	substring3
	btoi
	frame_bury 2 // c: uint64

	// tests/contracts/math.algo.ts:222
	// return c;
	frame_dig 2 // c: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// foobar(uint128)uint128
*abi_route_foobar:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// x: uint128
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 16
	==

	// argument 0 (x) for foobar must be a uint128
	assert

	// execute foobar(uint128)uint128
	callsub foobar
	dup
	bitlen
	intc 6 // 128
	<=

	// foobar return value overflowed 128 bits
	assert
	bytec 4 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 3 // 16
	-
	swap
	substring3
	concat
	log
	intc 0 // 1
	return

// foobar(x: uint128): uint128
foobar:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// tests/contracts/math.algo.ts:226
	// avgStake: uint128 = x / (30000 as uint128)
	frame_dig -1 // x: uint128
	pushbytes 0x00000000000000000000000000007530
	b/
	dup
	bitlen
	intc 6 // 128
	<=

	// x / (30000 as uint128) overflowed 128 bits
	assert
	bytec 4 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 3 // 16
	-
	swap
	substring3
	frame_bury 0 // avgStake: uint128

	// tests/contracts/math.algo.ts:228
	// return avgStake;
	frame_dig 0 // avgStake: uint128

	// set the subroutine return value
	frame_bury 0
	retsub

// uintFromHex()uint256
*abi_route_uintFromHex:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// execute uintFromHex()uint256
	callsub uintFromHex
	dup
	bitlen
	intc 2 // 256
	<=

	// uintFromHex return value overflowed 256 bits
	assert
	bytec 2 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 1 // 32
	-
	swap
	substring3
	concat
	log
	intc 0 // 1
	return

// uintFromHex(): uint256
uintFromHex:
	proto 0 1

	// tests/contracts/math.algo.ts:232
	// return Uint<256>('0xFF');
	pushbytes 0x00000000000000000000000000000000000000000000000000000000000000ff
	retsub

// wideRatioTest()uint64
*abi_route_wideRatioTest:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// execute wideRatioTest()uint64
	callsub wideRatioTest
	itob
	concat
	log
	intc 0 // 1
	return

// wideRatioTest(): uint64
wideRatioTest:
	proto 0 1

	// tests/contracts/math.algo.ts:236
	// return wideRatio([Uint<64>('18446744073709551615'), 2, 3, 4, 5], [2, 3, 4, 5]);
	intc 7 // 18446744073709551615
	intc 8 // 2
	mulw
	intc 9 // 3
	uncover 2
	dig 1
	*
	cover 2
	mulw
	cover 2
	+
	swap
	intc 10 // 4
	uncover 2
	dig 1
	*
	cover 2
	mulw
	cover 2
	+
	swap
	intc 11 // 5
	uncover 2
	dig 1
	*
	cover 2
	mulw
	cover 2
	+
	swap
	intc 8 // 2
	intc 9 // 3
	mulw
	intc 10 // 4
	uncover 2
	dig 1
	*
	cover 2
	mulw
	cover 2
	+
	swap
	intc 11 // 5
	uncover 2
	dig 1
	*
	cover 2
	mulw
	cover 2
	+
	swap
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	retsub

// u128InTuple((uint64,uint64,uint128),uint128,uint64)uint128
*abi_route_u128InTuple:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// scale: uint64
	txna ApplicationArgs 3
	btoi

	// accRps: uint128
	txna ApplicationArgs 2
	dup
	len
	intc 3 // 16
	==

	// argument 1 (accRps) for u128InTuple must be a uint128
	assert

	// userData: (uint64,uint64,uint128)
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 2 (userData) for u128InTuple must be a (uint64,uint64,uint128)
	assert

	// execute u128InTuple((uint64,uint64,uint128),uint128,uint64)uint128
	callsub u128InTuple
	dup
	bitlen
	intc 6 // 128
	<=

	// u128InTuple return value overflowed 128 bits
	assert
	bytec 4 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 3 // 16
	-
	swap
	substring3
	concat
	log
	intc 0 // 1
	return

// u128InTuple(userData: UserData, accRps: uint128, scale: uint64): uint128
u128InTuple:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// tests/contracts/math.algo.ts:242
	// this.accRPS.value = accRps
	bytec 8 //  "rewardPerShare"
	frame_dig -2 // accRps: uint128
	app_global_put

	// tests/contracts/math.algo.ts:243
	// retVal = clone(userData)
	frame_dig -1 // userData: UserData
	frame_bury 0 // retVal: (uint64,uint64,uint128)

	// tests/contracts/math.algo.ts:245
	// retVal.rewardDebt = ((userData.stake as uint128) * (this.accRPS.value as uint128)) / (scale as uint128)
	frame_dig 0 // retVal: (uint64,uint64,uint128)
	intc 3 //  headOffset
	frame_dig -1 // userData: UserData
	extract 0 8
	btoi
	itob
	bytec 8 //  "rewardPerShare"
	app_global_get
	b*
	frame_dig -3 // scale: uint64
	itob
	b/
	dup
	bitlen
	intc 6 // 128
	<=

	// retVal.rewardDebt overflowed 128 bits
	assert
	bytec 4 // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 3 // 16
	-
	swap
	substring3
	replace3
	frame_bury 0 // retVal: (uint64,uint64,uint128)

	// tests/contracts/math.algo.ts:247
	// return retVal.rewardDebt;
	frame_dig 0 // retVal: (uint64,uint64,uint128)
	extract 16 16

	// set the subroutine return value
	frame_bury 0
	retsub

*abi_route_createApplication:
	intc 0 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x3ce6f1af // method "u64plus(uint64,uint64)uint64"
	pushbytes 0x0031a186 // method "u64minus(uint64,uint64)uint64"
	pushbytes 0xe52e4394 // method "u64mul(uint64,uint64)uint64"
	pushbytes 0x950d4789 // method "u64div(uint64,uint64)uint64"
	pushbytes 0x65bdda6e // method "u256plus(uint256,uint256)uint256"
	pushbytes 0x0a6ad284 // method "u256minus(uint256,uint256)uint256"
	pushbytes 0xf044bf24 // method "u256mul(uint256,uint256)uint256"
	pushbytes 0xc48f8c05 // method "u256div(uint256,uint256)uint256"
	pushbytes 0xf2e1d632 // method "u64Return256(uint64,uint64)uint256"
	pushbytes 0x38b1a39e // method "maxU64()uint64"
	pushbytes 0x6c136f1d // method "exponent(uint64,uint64)uint64"
	pushbytes 0x22da2502 // method "variableTypeHint(uint8,uint8)uint16"
	pushbytes 0xa2fead6c // method "uint8plus(uint8,uint8)uint8"
	pushbytes 0xd2256f7a // method "uint8exp(uint8,uint8)uint8"
	pushbytes 0xc17d624e // method "plusEquals(uint64,uint64)uint64"
	pushbytes 0x5cab0438 // method "plusEqualsFromGlobal(uint64,uint64)uint64"
	pushbytes 0x58989ccd // method "boxTest()uint256"
	pushbytes 0x4830b4de // method "unsafeMethodArgs(uint256,uint256)uint256"
	pushbytes 0xe1c55ce5 // method "uint256ComparisonType(uint256,uint256)void"
	pushbytes 0x7d1d426e // method "squareRoot256(uint256,uint256)uint256"
	pushbytes 0x1c2981f1 // method "squareRoot64(uint64,uint64)uint64"
	pushbytes 0xb7ca04b9 // method "addressToBigInt(address)bool"
	pushbytes 0xbb952338 // method "u8Tou64()uint64"
	pushbytes 0x0128e27b // method "funcName(uint256)void"
	pushbytes 0xf916cdb3 // method "bigintPlus(uint64,uint64)uint64"
	pushbytes 0x52737545 // method "bitwiseOr(uint64,uint64)uint64"
	pushbytes 0x79c1adc0 // method "bitwiseAnd(uint64,uint64)uint64"
	pushbytes 0x22474abc // method "bitwiseXor(uint64,uint64)uint64"
	pushbytes 0x0593fdf8 // method "bitwiseOrU256(uint256,uint256)uint256"
	pushbytes 0x06fb9337 // method "bitwiseAndU256(uint256,uint256)uint256"
	pushbytes 0x26493d78 // method "bitwiseXorU256(uint256,uint256)uint256"
	pushbytes 0xe9c22eea // method "bitwiseNot(uint64)uint64"
	pushbytes 0xede3e9bc // method "bitwiseNotU256(uint256)uint256"
	pushbytes 0x2e4a2164 // method "mulw(uint64,uint64)uint64"
	pushbytes 0x50134b5a // method "addw(uint64,uint64)uint64"
	pushbytes 0xf53aff9b // method "expw(uint64,uint64)uint64"
	pushbytes 0xcaf7110d // method "divw(uint64,uint64)uint64"
	pushbytes 0xbed0e386 // method "divmodw(uint64,uint64)uint64"
	pushbytes 0x274d7705 // method "unsafeVariables()uint64"
	pushbytes 0x92465d08 // method "foobar(uint128)uint128"
	pushbytes 0xf01facce // method "uintFromHex()uint256"
	pushbytes 0x5ac8a0a0 // method "wideRatioTest()uint64"
	pushbytes 0xcfb00692 // method "u128InTuple((uint64,uint64,uint128),uint128,uint64)uint128"
	txna ApplicationArgs 0
	match *abi_route_u64plus *abi_route_u64minus *abi_route_u64mul *abi_route_u64div *abi_route_u256plus *abi_route_u256minus *abi_route_u256mul *abi_route_u256div *abi_route_u64Return256 *abi_route_maxU64 *abi_route_exponent *abi_route_variableTypeHint *abi_route_uint8plus *abi_route_uint8exp *abi_route_plusEquals *abi_route_plusEqualsFromGlobal *abi_route_boxTest *abi_route_unsafeMethodArgs *abi_route_uint256ComparisonType *abi_route_squareRoot256 *abi_route_squareRoot64 *abi_route_addressToBigInt *abi_route_u8Tou64 *abi_route_funcName *abi_route_bigintPlus *abi_route_bitwiseOr *abi_route_bitwiseAnd *abi_route_bitwiseXor *abi_route_bitwiseOrU256 *abi_route_bitwiseAndU256 *abi_route_bitwiseXorU256 *abi_route_bitwiseNot *abi_route_bitwiseNotU256 *abi_route_mulw *abi_route_addw *abi_route_expw *abi_route_divw *abi_route_divmodw *abi_route_unsafeVariables *abi_route_foobar *abi_route_uintFromHex *abi_route_wideRatioTest *abi_route_u128InTuple

	// this contract does not implement the given ABI method for call NoOp
	err